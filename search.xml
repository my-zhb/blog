<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二进制的原码、反码、补码</title>
      <link href="2020/12/10/c3d59d66.html"/>
      <url>2020/12/10/c3d59d66.html</url>
      
        <content type="html"><![CDATA[<ol><li>计算机在任何情况下都只能识别二进制</li><li>计算机在底层存储数据的时候，一律存储的是”二进制的补码形式”，计算机采用补码形式存储数据的原因是：补码形式效率最高</li><li>什么是补码？<br>二进制有：原码 反码 补码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于一个正数来说：二进制原码、反码、补码是同一个，完全相同</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">对应的二进制原码：<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span></span><br><span class="line">对应的二进制反码：<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span></span><br><span class="line">对应的二进制补码：<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对一个负数来说：二进制原码、反码、补码是什么关系呢？</span></span><br><span class="line"><span class="keyword">byte</span> i = -<span class="number">1</span>;</span><br><span class="line">对应的二进制原码： <span class="number">10000001</span></span><br><span class="line">对应的二进制反码(符号位不变，其他位取反)： <span class="number">11111110</span></span><br><span class="line">对应的二进制补码(反码+<span class="number">1</span>)： <span class="number">11111111</span></span><br></pre></td></tr></table></figure>问题：byte b = (byte)150；输出多少？？<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)<span class="number">150</span>;<span class="comment">//这里输出-106</span></span><br><span class="line"></span><br><span class="line">    <span class="number">128</span> <span class="number">64</span> <span class="number">32</span> <span class="number">16</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line">    <span class="number">1</span>   <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> （这里是<span class="number">128</span>，<span class="number">150</span>-<span class="number">128</span>=<span class="number">22</span>）</span><br><span class="line">    <span class="number">1</span>   <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> （<span class="number">16</span>+<span class="number">4</span>+<span class="number">2</span>=<span class="number">22</span>）</span><br><span class="line">    </span><br><span class="line"><span class="number">11001</span> <span class="number">0110</span> (最终结果这是一个二进制补码形式)</span><br><span class="line">二进制原码为：<span class="number">1110</span> <span class="number">1010</span></span><br><span class="line">二进制反码为：<span class="number">1001</span> <span class="number">0101</span></span><br><span class="line">二进制补码为：<span class="number">1001</span> <span class="number">0110</span></span><br><span class="line">其中符号位是<span class="number">1</span>所以是负数</span><br><span class="line"><span class="number">0</span>+<span class="number">2</span>+<span class="number">0</span>+<span class="number">8</span>+<span class="number">0</span>+<span class="number">32</span>+<span class="number">64</span>=-<span class="number">106</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="2020/12/09/23a3bd72.html"/>
      <url>2020/12/09/23a3bd72.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><ol><li>软件程序运行过程中，非常可能遇到问题，这就是异常。</li><li>异常指程序运行中出现的不期而遇的各种状况，如：文件找不到，网络连接失败等。</li><li>异常发生在程序运行期间，它影响了正常的程序执行流程。</li><li>一次在Java中以类的形式存在，每一个异常类都可以创建异常对象</li></ol><h1 id="异常分为三种类型"><a href="#异常分为三种类型" class="headerlink" title="异常分为三种类型"></a>异常分为三种类型</h1><ol><li>检查性异常<br>最具代表的检查性异常时用户错误或问题引发的异常，这是程序员无法预见的，例如打开了一个不存在的文件时，一个异常就发送了，这些异常在编译时不能被简单地忽略。</li><li>运行时异常<br>运行时异常时可以被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li>错误<br>错误不是异常，而实脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ol><h1 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h1><ol><li>Java把异常当作对象来处理，并定义一个基类java.long.Throwable做为所有异常的超类。</li><li>在Java API中已定义了很多异常类，这些异常类分为两大类<ul><li>错误 Error</li><li>异常 Exception</li></ul></li></ol><h1 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h1><p>处理异常的五个关键字</p><ul><li>try  （try…catch，可以只有try）</li><li>catch   （catch和try连用，没有try是不行的）</li><li>finally （不管什么情况，finally块中的代码都会执行,除非碰到System.exit(0)退出jvm虚拟机）</li><li>throw() （throw()主动抛出异常）</li><li>throws （throws向上级抛出异常，如果抛到jvm虚拟机，程序将直接停止）</li></ul><p>try…cathc语句中出现finally块，不管程序是否出现异常或者return，finally块中的代码都会执行，除非碰到System.exit(0)退出jvm虚拟机。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch&quot;</span>)</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finaly&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><ol><li>创建自定义异常类。</li><li>在方法中通过throw关键字抛出异常对象。</li><li>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处理throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义异常extends Exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyException&#123;&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;自定义了一个异常&#125;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常问题"><a href="#异常问题" class="headerlink" title="异常问题"></a>异常问题</h1><ol><li>个人理解如果方法内，return 返回的对象可以不用赋值的话，在finally里面就可以更改，如果必须赋初始化值，finally里面就无法改变，列入：<br> String s = null; 不可改变<br> List list = null;不可改变<br> List list = new ArryList();可改变 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ages)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = m();</span><br><span class="line">        <span class="comment">//输出100</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Java语法规则（有一些规则是不能破坏的，一旦这么说，就必须这么做！）</span></span><br><span class="line">    <span class="comment">/**Java中有一条这样的规则：</span></span><br><span class="line"><span class="comment">      * 1.方法体中的代码必须遵循自上而下顺序依次逐行执行！</span></span><br><span class="line"><span class="comment">      * 2.return语句一旦执行，整个方法必须结束！</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//这行代码出现在int i = 100 的下面，所以最终结果必须是返回100</span></span><br><span class="line">            <span class="comment">//return语句还必须保证是最后执行的，一旦执行，整个方法结束。</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. final、finally、finalize的区别？</span><br><span class="line">    1. final是一个关键字，表示最终的，不可变的</span><br><span class="line">    2. finally也是一个关键字，和try联合使用，使用在异常机制中，finally语句块中的代码是一定会执行的。</span><br><span class="line">    3. finalize()是Object类中的一个方法。作为方法名称出现，所以finalize是一个标识符。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="2020/12/09/9bc01b38.html"/>
      <url>2020/12/09/9bc01b38.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是内部类"><a href="#什么是内部类" class="headerlink" title="什么是内部类"></a>什么是内部类</h1><p>内部类就是在一个类的内部在定义一个类，比如，A类中定义一个B类，那么B类相对于A类来说就成为内部类，而A类相对B类来说就是外部类。</p><h1 id="内部类分为4种"><a href="#内部类分为4种" class="headerlink" title="内部类分为4种"></a>内部类分为4种</h1><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外部类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是内部类的方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内部类可获取外部的私有属性</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getID</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//通过外部类实例化内部类</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.in();</span><br><span class="line">        inner.getID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外部类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是内部类的方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//静态内部类是无法拿到外部类的私有属性的，因为静态的会先被加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Outer.Inner.in();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="comment">//局部内部类</span></span><br><span class="line">    <span class="comment">//在方法里定义的类 就是局部内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//没有名字初始化类，不用将实例保存到变量中，就是匿名内部类</span></span><br><span class="line">       <span class="keyword">new</span> Outer().method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="2020/12/08/5951da65.html"/>
      <url>2020/12/08/5951da65.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h1><ul><li>普通类：只有具体实现</li><li>抽象类：具体实现和规范(抽象方法)都有！</li><li>接口：只有规范！</li></ul><ol><li>接口就是规范，定义的是一组规则，体现了现实世界中”如果你是…则必须能…”的思想。如果你是天使则必须能飞。</li><li><code>接口的本质是契约</code>，就像我们人类的法律一样。制定好后大家都遵守。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义接口的关键字 interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接口里面的方法都是抽象的 public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类 可以实现接口 通过关键字 implements</span></span><br><span class="line"><span class="comment">//实现接口就不必重写接口里面的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="==总结=="></a>==<strong>总结</strong>==</h1><ol><li>接口就是一种约束(<code>接口里面只能出现抽象方法和常量</code>)</li><li>接口定义了一些方法，可以让不同的人实现</li><li>接口里面定义的方法都是 public abstract (<code>可以直接忽略不写</code>)</li><li>接口里面定义的常量都是 public static final (<code>可以直接忽略不写</code>)</li><li>接口不能被实例化，接口中没有构造方法。</li><li>implements可以实现多个接口</li><li>类实现了接口就必须重写接口里面的方法。</li><li>接口中的方法都是抽象方法，所以接口里的方法不能有方法体。</li><li>接口可以多继承接口。</li><li>实现接口的类，方法的访问权限不能比接口底。</li><li>接口的使用离不开多态度机制（接口+多态才能达到解耦合）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里是多态的一种表现</span></span><br><span class="line">        <span class="comment">//抽象类是不能够被实例化的</span></span><br><span class="line">        MyMath my = <span class="keyword">new</span> MyMathImpl();</span><br><span class="line">        my.sum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="comment">//  public static final double PI=3.1415936; 效果一样，可以省略不写 public static final    </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//  public abstract int sum(int a,int b); 效果与上面的一样 这里public abstract可以省略    </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非抽象类实现了抽象类必须重写方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMathImpl</span> <span class="keyword">implements</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*  这里的访问修饰符不能比抽象类方法的访问修饰符权限低 只能比它高  </span></span><br><span class="line"><span class="comment">    private int sum(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与对象的关系</title>
      <link href="2020/12/08/d1212574.html"/>
      <url>2020/12/08/d1212574.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a>什么是类？</h1><p><code>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表每一个具体的事物</code></p><h1 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h1><p><code>对象是抽象概念的具体实例</code></p><h2 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h2><ul><li><code>使用new关键字创建对象</code></li><li>使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认初始化以及对类中构造器的调用。</li><li>类中的构造器也被称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点  <ol><li>必须和类的名称相同</li><li>必须没有返回类型，也不能写void</li></ol></li></ul><p>重点：<code>类里面定义了有参构造器就必须定义一个无参构造器</code></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类</title>
      <link href="2020/12/07/3dbae4e.html"/>
      <url>2020/12/07/3dbae4e.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是抽象类"><a href="#什么是抽象类" class="headerlink" title="什么是抽象类"></a>什么是抽象类</h1><ol><li>abstract修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法，如果修饰类那么该类就是抽象。</li><li>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。</li><li>抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。</li><li>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。</li><li>子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。</li><li>抽象类里面可以写普通方法。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//abstract 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//约束·有人帮忙实现</span></span><br><span class="line">    <span class="comment">//abstract 抽象方法，只有 方法名称 没有方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类的方法必须要有继承它的子类去实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h1><ol><li>抽象类不能new出来，只能靠子类去实现它，是一种约束!</li><li>抽象类中可以写普通的方法。</li><li>抽象方法必须在抽象类中。</li><li>抽象类也是属于引用数据类型。</li><li>抽象类的子类也可以是抽象类。</li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>抽象类里面有构造方法吗？<br>有</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">s</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static关键字</title>
      <link href="2020/12/06/ce244871.html"/>
      <url>2020/12/06/ce244871.html</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ages)</span></span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">匿名代码块</span><br><span class="line">构造方法</span><br><span class="line">===============</span><br><span class="line">匿名代码块</span><br><span class="line">构造方法</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>第一次执行先执行静态代码块 在执行匿名代码块 最后执行构造方法</li><li>静态方法只执行一次</li></ol><h1 id="静态导入包"><a href="#静态导入包" class="headerlink" title="静态导入包"></a>静态导入包</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态导入包</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.<span class="keyword">long</span>.Math.random;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.<span class="keyword">long</span>.Math.PI;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ages)</span></span>&#123;</span><br><span class="line">        System.out.println(random());</span><br><span class="line">        System.out.println(PI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态属性及方法"><a href="#静态属性及方法" class="headerlink" title="静态属性及方法"></a>静态属性及方法</h1><p>静态的属性和方法可以直接通过类名调用</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的3大特征</title>
      <link href="2020/12/05/7867351e.html"/>
      <url>2020/12/05/7867351e.html</url>
      
        <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ol><li><p>该露的露，该藏的藏</p><p> 我们程序设计追求<code>高内聚，低耦合</code>。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅量暴露少量的方法给我外部使用</p></li><li><p>封装（数据的隐藏）</p><p> 通常，应静止直接访问一个对象中的实际表示，而应通过操作接口来访问，这称为信息隐藏。</p></li></ol><p><code>记住这句话就够了：属性私有，get/set</code></p><p><code>封装的核心private私有化</code></p><h2 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h2><ol><li>提高程序的安全性，保护数据</li><li>隐藏代码的实现细节</li><li>统一接口</li><li>系统可维护性增加</li></ol><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol><li>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</li><li><code>extends</code>的意思是”扩展”。子类是分类的扩展。</li><li><code>Java中类只有单继承，没有多继承！</code></li><li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</li><li>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示。</li><li>子类和父类之间，从意义上讲应该具有”is a”的关系。  </li></ol><p>重点：</p><ul><li>object类  </li><li>super  </li><li>方法重写 </li></ul><h2 id="继承注意"><a href="#继承注意" class="headerlink" title="继承注意"></a>继承注意</h2><ol><li><p>super注意点：</p><ul><li>super调用父类的构造方法，必须在构造方法的第一个</li><li>super必须只能出现在子类的构造方法中！</li><li>super和this不能同时调用构造方法！</li></ul></li><li><p>this</p><ol><li>代表的不同对象：<ul><li>this:本身调用者这个对象</li><li>super：代表父类对象的引用</li></ul></li><li>前提<ul><li>this：没有继承也可以使用</li><li>super：只能在继承条件才可以使用</li></ul></li><li>构造方法<ul><li>this() 本类的构造</li><li>super() 父类的构造</li></ul></li></ol></li></ol><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><ol><li>重写都是方法的重写，和属性无关</li><li>构造方法不能被继承，所以构造方法也不能被重写。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123; </span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1==&gt;A==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="comment">//Override 重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2==&gt;B==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//方法的调用只和左边定义的数据类型有关</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//父类的引用指向了子类</span></span><br><span class="line">        B b = <span class="keyword">new</span> A();<span class="comment">//非静态下子类重写了父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态方法输出结果</span></span><br><span class="line">B==&gt;test()</span><br><span class="line">A==&gt;test()</span><br><span class="line"></span><br><span class="line"><span class="comment">//非静态方法输出结果</span></span><br><span class="line">test2==&gt;B==&gt;test()</span><br><span class="line">test2==&gt;B==&gt;test()</span><br></pre></td></tr></table></figure><h2 id="重写注意"><a href="#重写注意" class="headerlink" title="重写注意"></a>重写注意</h2><ol><li>需要有继承关系，子类重写父类的方法！</li><li>方法名必须相同</li><li>参数列表必须相同</li><li>修饰符：范围可以扩大但不能缩小，public&gt;Protected&gt;Default&gt;private</li><li>抛出的异常：<ul><li>编译时异常：范围可以缩小，但不能扩大。ClassNotFoundException–&gt;Exception(大)</li><li>运行时异常：可以直接抛出！</li></ul></li><li>重写，子类的方法和父类必须要一致，方法体不同！</li><li>只要子类重写了父类的方法一定走的是子类的方法。  </li><li>方法覆盖只是针对方法，和属性无关。</li><li>私有方法无法被覆盖</li><li>方法重写只针对实例方法。  </li><li>为什么需要重写：<ul><li>父类的功能，子类不一定需要，或者不一定满足！</li></ul></li></ol><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ol><li>动态编译：类型：可扩展性</li><li>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</li><li>一个对象的实现类型是确定的，但可以只想对象的引用的类型很多。</li><li>多态存在的条件<ul><li>有继承关系</li><li>子类重写父类方法</li><li>父类引用指向子类对象</li></ul></li></ol><h2 id="多态注意"><a href="#多态注意" class="headerlink" title="多态注意"></a>多态注意</h2><ol><li>多态是方法的多态，属性没有多态性</li><li>父类和子类，有联系 类型转换异常！ ClassCastException!</li><li>存在条件：继承关系，方法需要重写，父类引用指向子类对象！ Father f1 = new Son();<ul><li>但有些方法是不能被重写的！<ul><li>static 方法，属于类，它不属于实例；</li><li>final 常量；</li><li>private 方法；</li></ul></li></ul></li></ol><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p>严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;go&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//Object &gt; String</span></span><br><span class="line">        <span class="comment">//Object &gt; Person &gt; Teacher</span></span><br><span class="line">        <span class="comment">//Object &gt; Person &gt; Student</span></span><br><span class="line">        Object object = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Student);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Teacher);<span class="comment">//false</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> String);<span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>总结</code><br>X instanceof Y 如果没有父子关系编译直接报错。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//类型之间的转换</span></span><br><span class="line">        <span class="comment">//高                低</span></span><br><span class="line">        Person obj = <span class="keyword">new</span> Student();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//obj，我们就可以使用Student类型的方法</span></span><br><span class="line">        <span class="comment">//高转低 需要强制转换</span></span><br><span class="line">        <span class="comment">//子类转父类(低转高) 可能会丢失自己本身的一些方法</span></span><br><span class="line">        Student student=(Student)obj;</span><br><span class="line">        student.go();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态总结"><a href="#多态总结" class="headerlink" title="多态总结"></a>多态总结</h2><ol><li>父类引用指向子类的对象。</li><li>把子类转换成父类，向上转型。</li><li>把父类转成子类，向下转型，强制转换。</li><li>方便方法的调用，减少重复的代码。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 封装 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是面向过程、面向对象</title>
      <link href="2020/12/04/c5d97b3b.html"/>
      <url>2020/12/04/c5d97b3b.html</url>
      
        <content type="html"><![CDATA[<h1 id="面向过程思想"><a href="#面向过程思想" class="headerlink" title="面向过程思想"></a>面向过程思想</h1><ol><li><p>步骤清晰简单，第一步做什么，第二步做什么。</p></li><li><p>面对过程适合处理一些较为简单的问题。</p></li><li><p>面向过程都是有因果关系的，比如，因为A所以才有B….</p></li></ol><p><code>面向过程的缺点：高耦合,可扩展性差，一步错步步错。</code></p><p><code>面向过程的优点：对于小型项目，效率较高，不用抽取对象，可直接编码。</code></p><h1 id="什么是OOA、OOD、OOP"><a href="#什么是OOA、OOD、OOP" class="headerlink" title="什么是OOA、OOD、OOP"></a>什么是OOA、OOD、OOP</h1><ol><li>OOA 面向对象分析</li><li>OOD 面向对象设计</li><li>OOP 面向对象编码</li></ol><h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><ol><li><p>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后才对某个分类下的细节进行面向过程的思考。</p></li><li><p>面向对象适合处理复杂的问题，适合处理需要多人协作的问题!</p></li><li><p><code>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</code></p></li></ol><h1 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h1><ol><li><p>面向对象编程的本质就是：<code>以类的方式组织代码，以对象的组织（封装）数据</code></p></li><li><p>抽象（抽象就是抽取事物的相同点）</p></li><li><p>封装（封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制）</p><ul><li><p>良好的封装能够减少耦合。</p></li><li><p>类内部的结构可以自由修改。</p></li><li><p>可以对成员变量进行更精确的控制。</p></li><li><p>隐藏信息，实现细节。 </p></li></ul></li><li><p>继承</p></li><li><p>多态（一种事物有多种形态）</p></li><li><p>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</p></li><li><p>从代码运行角度考虑是先有类后有对象。类是对象的模板。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 面向过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组</title>
      <link href="2020/12/03/a6455d41.html"/>
      <url>2020/12/03/a6455d41.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是稀疏数组？"><a href="#什么是稀疏数组？" class="headerlink" title="什么是稀疏数组？"></a>什么是稀疏数组？</h1><ol><li>当一个数组中大步幅元素为0，或者为同一个值的数组是，可以使用稀疏数组来保持该数组。</li><li>稀疏数组的处理方式<ul><li>记录数组一共有几行几列，有多少个不同值</li><li>把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">10</span>];</span><br><span class="line">array[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">array[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">System.err.println(<span class="string">&quot;输出棋盘:&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">System.out.print(array[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//获取有效数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(array[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">count = ++count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[][] num = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//获取总共有多少行</span></span><br><span class="line">num[<span class="number">0</span>][<span class="number">0</span>] = array.length;</span><br><span class="line"><span class="comment">//获取总共有多少列</span></span><br><span class="line">num[<span class="number">0</span>][<span class="number">1</span>] = array[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">//赋值有效数据</span></span><br><span class="line">num[<span class="number">0</span>][<span class="number">2</span>] = count;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//获取稀疏数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(array[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">num[number][<span class="number">0</span>] = i;</span><br><span class="line">num[number][<span class="number">1</span>] = j;</span><br><span class="line">num[number][<span class="number">2</span>] = array[i][j];</span><br><span class="line">number++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.err.println(<span class="string">&quot;转换后的结果:&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[i].length; j++) &#123;</span><br><span class="line">System.out.print(num[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//取出稀疏数组的行列</span></span><br><span class="line"><span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[num[<span class="number">0</span>][<span class="number">0</span>]][num[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">System.err.println(<span class="string">&quot;还原稀疏数组:&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//渲染稀疏数组有效值从第一行开始渲染</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">nums[num[i][<span class="number">0</span>]][num[i][<span class="number">1</span>]] = num[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i].length; j++) &#123;</span><br><span class="line">System.out.print(nums[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出棋盘:</span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">1</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">5</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line">转换后的结果:</span><br><span class="line">列  行  值</span><br><span class="line"><span class="number">11</span><span class="number">10</span><span class="number">2</span>   <span class="comment">//第一行表示一共有11行10列有效值为2个</span></span><br><span class="line"><span class="number">1</span><span class="number">2</span><span class="number">1</span>   <span class="comment">//第二行表示第一个值在第1行第2列值是1</span></span><br><span class="line"><span class="number">3</span><span class="number">4</span><span class="number">5</span>   <span class="comment">//第三行表示第二个值在第3行第4列值是5，以此类推</span></span><br><span class="line">还原稀疏数组:</span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">1</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">5</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组及多维数组</title>
      <link href="2020/12/02/4cb979a2.html"/>
      <url>2020/12/02/4cb979a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h1><ol><li>数组时相同类型数据的有序集合。</li><li>数据描述的时相同类型的若干个数据，按照一定的先后次序排列组合而成。</li><li>其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们。</li></ol><h1 id="数组的4个基本特点"><a href="#数组的4个基本特点" class="headerlink" title="数组的4个基本特点"></a>数组的4个基本特点</h1><ol><li>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</li><li>其元素必须是相同类型，不允许出现混合类型。</li><li>数组中的元素可以是任何数据类型，包括旗本类型和引用类型。</li><li><code>数组变量属引用类型</code>，数组也可以看成对象，数组中的每个元素相当于对象的成员变量。数组本身就是对象，Java中对象是在推中的，因此数组无论保存原始类型还是其他对象类型，<code>数组对象本身就是堆中的</code></li><li>数组在内存方面存储的时候，数组中的元素内存地址是连续的。</li></ol><h1 id="数组这种数据结构的优点和缺点"><a href="#数组这种数据结构的优点和缺点" class="headerlink" title="数组这种数据结构的优点和缺点?"></a>数组这种数据结构的优点和缺点?</h1><ol><li>优点 查询/查找/检索某个下标上的元素时效极高，可以说是查询效率最高的一个数据结构。<br>  为什么检索效率高？<ol><li>每一个元素的内存地址在空间存储上是连续的。</li><li>每一个元素类型相同，所以占用空间大小一样。</li><li>知道第一个元素内存地址，知道每一个元素占用空间的大小，又知道下标，所以通过一个数学表达式就可以计算出某个下标元素上元素的内存地址，直接通过内存地址定位元素，所以数组的检索效率是最高的。</li><li><code>数组中存储100个元素或者存储100w个元素，在效率是相同的，因为数组中的元素不是一个个找的，而是通过数学表达式算内存地址直接定位的</code></li></ol></li><li>缺点<ol><li>由于为了保证数组中每个元素的内存地址连续，所以在数组中随机删除和添加的时候，效率较低，因为随机增删元素都会影响后面元素的位移操作（<code>注意：对于数组最后一个元素的增删，是没用效率影响的</code>）。</li><li>数组不能存储大数据量，为什么？<br>因为很难再内存空间上找到一块特别大的连续的内存空间.</li></ol></li></ol><h1 id="数组的3种初始化"><a href="#数组的3种初始化" class="headerlink" title="数组的3种初始化"></a>数组的3种初始化</h1><ol><li>静态初始化</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] num = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>动态初始化</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">num[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">num[<span class="number">2</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>默认初始化<br>数组才被创建的时候，就有默认的值，这个值也就是数组类型的默认值。</li></ol><p><code>备注：变量是放在栈里面的，new出来的是放在堆里面的</code></p><h1 id="数组的扩容"><a href="#数组的扩容" class="headerlink" title="数组的扩容"></a>数组的扩容</h1><p>关于一位数组的扩容。<br>Java中对数组的扩容是: 先新建一个大容量的数组然后将小容量数组中的数据一个个拷贝到大数组中。<br><code>总结:数组扩容效率较低，因为涉及到拷贝的问题，所以尽可能少的进行数组的拷贝 </code><br>可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这要可以减少数组的扩容次数，提高效率</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拷贝源（从这个数组中拷贝）</span></span><br><span class="line">        <span class="keyword">int</span>[] src = &#123;<span class="number">1</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拷贝目标（拷贝到这个目标数组上）</span></span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 调用jdk System类中的arraycopy方法进行数据的拷贝</span></span><br><span class="line"><span class="comment">         * arraycopy方法对应参数如下</span></span><br><span class="line"><span class="comment">         * src 拷贝源</span></span><br><span class="line"><span class="comment">         * srcPos 拷贝的起始位置</span></span><br><span class="line"><span class="comment">         * dest 拷贝目标</span></span><br><span class="line"><span class="comment">         * destPos 拷贝到目标的起始位置</span></span><br><span class="line"><span class="comment">         * length 拷贝长度</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        System.arraycopy(src,<span class="number">1</span>,dest,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多位数组"><a href="#多位数组" class="headerlink" title="多位数组"></a>多位数组</h1><ul><li>多维数组可以看出是数组的数组，比如二位数组就是一个特殊的一位数组，其每一个元素都是一个一位数组（<a href="https://www.processon.com/view/link/5f49dce26376890e62f836a6/">二位数组图点击查看</a>）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">5</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//arry[3][2]</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1,2 arry[0]</span></span><br><span class="line"><span class="comment">            3,4 arry[1]</span></span><br><span class="line"><span class="comment">            5,6 arry[2]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span>[][] arry = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arry.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arry[i].length; j++)&#123;</span><br><span class="line">                System.out.println(arry[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java方法</title>
      <link href="2020/12/01/7a37a823.html"/>
      <url>2020/12/01/7a37a823.html</url>
      
        <content type="html"><![CDATA[<h1 id="何谓方法？"><a href="#何谓方法？" class="headerlink" title="何谓方法？"></a>何谓方法？</h1><p>Java方法是语句的集合，它们在一起执行一个功能。</p><ol><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ol><h1 id="设计方法的原则"><a href="#设计方法的原则" class="headerlink" title="设计方法的原则"></a>设计方法的原则</h1><p>方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的<code>原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展</code></p><h1 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h1><p>方法包含一个方法头河一个方法体</p><ul><li>修饰符：修饰符，这是可选的，告诉编译器如何调用该方法，定义了方法的访问类型。</li><li>返回值：方法可能会有返回值。</li><li>方法名：参数像是一个占位符，当方法被调用时，传递值给参数。</li><li>参数类型：参数是可选的，方法可以不包含任何参数。<ol><li>形式参数：在方法被调用时用于接收外界传入的数据</li><li>实参：调用方法是实际给方法的数据</li></ol></li><li>方法体：方法体包含具体的语句，定义该方法的功能。</li></ul><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ol><li>什么是值传递？<br><code>值传递是对基本类型而言，传递的是该变量的副本，改变副本不影响原变量</code></li><li>什么是引用传递？<br><code>引用传递一般是对对象变量而言，传递的是该对象的地址副本，并不是原对象本身。所以引用对象进行操作会同时改变原对象。</code></li></ol><p><code>所以一般认为Java类的传递都是值传递，而这个值，实际上是对象的引用。</code></p><h1 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h1><ol><li>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</li><li>方法的重载的规则：<ul><li>方法名称必须相同。</li><li>参数列表必须不同（个数不同、或者类型不同、参数排列顺序不同）。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为方法的重载。</li></ul></li></ol><p><code>总结：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</code></p><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><pre><code>JDK1.5开始，Java支持传递同类型的可变参数给一个方法。在方法声明中，在指定参数类型后加一个省略号（...）。一个方法中只能指定一个可变参数，它碧血时方法的最后一个参数，任何普通的参数必须在它之前声明</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>... number)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是变量、常量、作用域、final关键字以及变量的命名规范</title>
      <link href="2020/11/30/c278e9dc.html"/>
      <url>2020/11/30/c278e9dc.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol><li>变量是什么：就是可以变化的数据!</li><li>Java是一种强类型语言，每个变量都必须声明其类型。</li><li>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String userName = <span class="string">&quot;张三&quot;</span>；</span><br><span class="line"><span class="comment">//String 是数据类型</span></span><br><span class="line"><span class="comment">//userName 是变量名</span></span><br><span class="line"><span class="comment">//张三 是值</span></span><br></pre></td></tr></table></figure><p><code>注意</code></p><ul><li><code>每个变量都必须有类型，类型可以是基本类型，也可以是引用类型</code>。</li><li><code>变量名必须是合法的标识符</code>。</li><li><code>变量声明是一个完整的语句，因此每一个声明都必须以分号结束</code>。</li></ul><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ul><li>类变量（也可以叫做成员变量。使用static修饰）</li><li>实例变量</li><li>局部变量（写在方法里的）</li><li>Java中有一个很重要的原则：就近原则，那个就访问那个</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//这个是类变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这个是实例变量</span></span><br><span class="line">    String str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//这个是局部变量</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里i=0，这里就是Java中的就近原则</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="comment">//c变量赋值100，a、b只声明了没有赋值</span></span><br><span class="line">        <span class="keyword">int</span> a,b,c = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//这样每个都赋值了。</span></span><br><span class="line">        <span class="keyword">int</span> d=<span class="number">10</span>，e=<span class="number">10</span>,f=<span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ol><li>常量是初始化后不能再改变值!不会变动的值。</li><li>所谓常量可以理解成一种特殊的变量，它的值背设定后，在程序运行过程中不允许改变。</li><li>常量名一般用大写。</li><li>常量使用final关键字修饰</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//NUM就是常量 但是要使用final关键字修饰</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> NUM = <span class="number">2500</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h1><ol><li>所有变量、方法、类名要==见名如意==</li><li>类成员变量：首字母小写和驼峰原则：monthSalary</li><li>局部变量：首字母小写和驼峰原则</li><li>常量：首字母大写和下划线：MAX_VALUE</li><li>类名：首字母大写和驼峰原则：Man，GoodMan</li><li>方法名：首字母小写和驼峰原则：run(),runRun()</li></ol><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><ol><li>final是Java语言中的一个关键字。</li><li>final表示最终的，不可变的。</li><li>final可以修饰变量以及方法，还有类等。</li><li>final修饰的变量？<br>final修饰的变量，只能赋一次值，不允许被重新赋值。</li><li>final修饰的方法？<br>final修饰的方法无法被覆盖，被重写。</li><li>final修饰的类？<br>final修饰的类无法被继承</li><li>final控制不了能不能被调用的问题。final管的是啥？<br>final修饰的表示最后的，不能变得，不能改的。</li><li>final修饰的引用会怎么样呢？<br>final修饰的引用只能指向一个对象，不能被修改</li><li>final修饰的实例变量，系统不会赋默认值，必须手动赋值。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]agrs)</span></span>&#123;</span><br><span class="line">    <span class="comment">//final修饰的引用只能指向一个对象 ，但是被new出来的对象在堆中是可以被修改的</span></span><br><span class="line">        <span class="keyword">final</span> C c =<span class="keyword">new</span> C();</span><br><span class="line">        c.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(c.getName());</span><br><span class="line">        c.setName(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        System.out.println(c.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">张三</span><br><span class="line">王五</span><br></pre></td></tr></table></figure><h2 id="关于final赋值问题"><a href="#关于final赋值问题" class="headerlink" title="关于final赋值问题"></a>关于final赋值问题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="comment">//Java默认不会给final赋默认值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> i;</span><br><span class="line">    <span class="comment">//如果不在构造方法里赋值，程序启动报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i=<span class="number">80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量 </tag>
            
            <tag> 常量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java运算符</title>
      <link href="2020/11/29/778179f.html"/>
      <url>2020/11/29/778179f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java语言支持如下运算符"><a href="#Java语言支持如下运算符" class="headerlink" title="Java语言支持如下运算符"></a>Java语言支持如下运算符</h1><ul><li>算术运算符：+、-、*、/、%、++、–</li><li>赋值运算符：=</li><li>关系运算符：&gt;、&lt;、&gt;=、&lt;=、==、!=instanceof</li><li>逻辑运算符：&amp;&amp;、||、!、&amp;、|</li><li>位运算符：&amp;、|、^、~、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;</li><li>条件运算符:?、:</li><li>扩展赋值运算符:+=、-=、*=、/=、%=</li></ul><h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">21</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">25</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">25</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="number">1.</span>加号运算</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">        </span><br><span class="line">        <span class="number">2.</span>减号运算</span><br><span class="line">        System.out.println((a-b);</span><br><span class="line">        </span><br><span class="line">        <span class="number">3.</span>乘法运算</span><br><span class="line">        System.out.println(a*b);</span><br><span class="line">        </span><br><span class="line">        <span class="number">4.</span>除法运算</span><br><span class="line">        <span class="comment">//这里输出结果为：0 </span></span><br><span class="line">        <span class="comment">//为什么会是0，因为10/25 结果为0.5，int类型就转成0了</span></span><br><span class="line">        System.out.println(a/b);</span><br><span class="line">        </span><br><span class="line">        <span class="number">5.</span>%（取余）</span><br><span class="line">        <span class="comment">//输出结果：1</span></span><br><span class="line">        <span class="comment">//因为21/10 等于 2.1 余数为：1</span></span><br><span class="line">        System.out.println(b%a);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出结果：0</span></span><br><span class="line">        <span class="comment">//25/25 等于 1.0 余数为：0</span></span><br><span class="line">        System.out.println(c%d);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出结果：10</span></span><br><span class="line">        <span class="comment">//10/21 等于 0.476... 不满足1，返回a</span></span><br><span class="line">        System.out.println(a%b);</span><br><span class="line">        </span><br><span class="line">        <span class="number">6.</span>++，--(一元运算符)</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = a++;<span class="comment">//理解a++,表示这行代码执行后，先给b赋值，然后下次在+1</span></span><br><span class="line"><span class="keyword">int</span> c = a--;<span class="comment">//理解a--,表示这行代码执行后，先给b赋值，然后下次在-1</span></span><br><span class="line"><span class="keyword">int</span> d = ++a;<span class="comment">//理解++a,表示这行代码执行前，先+1，在给c赋值</span></span><br><span class="line"><span class="keyword">int</span> f = --a;<span class="comment">//理解--a,表示这行代码执行前，先-1，在给f赋值</span></span><br><span class="line">System.out.println(a);<span class="comment">//3</span></span><br><span class="line">System.out.println(b);<span class="comment">//3</span></span><br><span class="line">System.out.println(c);<span class="comment">//4</span></span><br><span class="line">System.out.println(d);<span class="comment">//4</span></span><br><span class="line">System.out.println(f);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自动升型</span></span><br><span class="line">        <span class="comment">//混合运算返回的结果类型是当前参与运算的最大类型</span></span><br><span class="line">        <span class="comment">//如果是（byte，char，short）类型进行混合运算 Java内部会自动转换成int类型</span></span><br><span class="line">        <span class="keyword">long</span> a1 = <span class="number">123123123123L</span>;</span><br><span class="line">        <span class="keyword">int</span> b1 = <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">short</span> c1 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">byte</span> d1 = <span class="number">8</span>;</span><br><span class="line">        System.out.println(a1+b1+c1+d1);<span class="comment">//输出结果为Long类型</span></span><br><span class="line">        System.out.println(b1+c1+d1);<span class="comment">//输出结果为int类型</span></span><br><span class="line">        System.out.println(c1+d1);<span class="comment">//输出结果为int类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><ul><li>&amp; 逻辑与运算：两个变量都为真，结果才为true</li><li>| 逻辑或运算：两个变量有一个为真，结果就为true<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> a = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出结果：false</span></span><br><span class="line">        <span class="comment">//逻辑与运算：两个变量都为真，结果才为true</span></span><br><span class="line">        System.out.println((a&amp;b));</span><br><span class="line">        <span class="comment">//输出结果：true</span></span><br><span class="line">        <span class="comment">//逻辑或运算：两个变量有一个为真，结果就为true</span></span><br><span class="line">        System.out.println((a|b));</span><br><span class="line">        <span class="comment">//输出结果：true</span></span><br><span class="line">        <span class="comment">//如果是真，则变为假，如果为假真变为真</span></span><br><span class="line">        System.out.println(!(a&amp;b))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="短路运算-如下"><a href="#短路运算-如下" class="headerlink" title="短路运算 如下:"></a>短路运算 如下:</h1><p>什么是短路与现（&amp;&amp;）象：右边表达式不执行，这种现象叫做短路现象。<br>什么是短路或现（||）象：当左边表达式为true的时候，后面的就不执行了，否则一直执行<br>从效率上来说短路运算符不逻辑运算符效率要高，因为逻辑运算符每个条件都会判断。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//&amp; 逻辑与 </span></span><br><span class="line">System.out.println(x&gt;y &amp; x&gt;y++);</span><br><span class="line"><span class="comment">//这里输出12，为什么呢，&amp; 逻辑与 x&gt;y=false 判断完成之后又执行了x&gt;y++,s所以这里输出12</span></span><br><span class="line">System.out.println(y);</span><br><span class="line"><span class="comment">//&amp;&amp; 短路与</span></span><br><span class="line">System.out.println(x&gt;y &amp;&amp; x&gt;y++);</span><br><span class="line"><span class="comment">//这里输出11，为什么呢，&amp; 逻辑与 x&gt;y=false 判断完第一个为false，直接结束</span></span><br><span class="line">System.out.println(y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//| 逻辑或 </span></span><br><span class="line">System.out.println(x&gt;y | x&gt;y++);<span class="comment">//结果false</span></span><br><span class="line"><span class="comment">//这里输出12，为什么呢，| 逻辑或  x&gt;y=false，执行x&gt;y++=false，它会全部执行完只要有一个true就为true</span></span><br><span class="line">System.out.println(y);</span><br><span class="line"><span class="comment">//|| 逻辑或</span></span><br><span class="line">System.out.println(x&gt;y || x&gt;y++);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//这里输出12，为什么呢，|| 逻辑或  x&gt;y=false,不满足条件 他会继续执行。</span></span><br><span class="line">System.out.println(y);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(x&lt;y || x&gt;y++);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//这里输出11，为什么呢，|| 逻辑或 x&lt;y=true,后面的判断不执行。</span></span><br><span class="line">System.out.println(y);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A = <span class="number">0011</span> <span class="number">1100</span></span><br><span class="line">B = <span class="number">0000</span> <span class="number">1101</span></span><br><span class="line">      </span><br><span class="line"><span class="number">1.</span>A&amp;B（A和B） 结果：<span class="number">0000</span> <span class="number">1100</span> （根据位运算）</span><br><span class="line">（A的第一位是<span class="number">0</span>，B的第一位是<span class="number">0</span>，结果为<span class="number">0</span>）</span><br><span class="line">（A的第二位是<span class="number">0</span>，B的第二位是<span class="number">0</span>，结果为<span class="number">0</span>）</span><br><span class="line">（A的第三位是<span class="number">1</span>，B的第三位是<span class="number">0</span>，结果为<span class="number">0</span>）</span><br><span class="line">（A的第四位是<span class="number">1</span>，B的第四位是<span class="number">0</span>，结果为<span class="number">0</span>）</span><br><span class="line">（A的第五位是<span class="number">1</span>，B的第五位是<span class="number">1</span>，结果为<span class="number">1</span>）以此类推</span><br><span class="line">      </span><br><span class="line"><span class="number">2.</span>A|B（A或者B） 结果：<span class="number">00111101</span></span><br><span class="line">解释：只要A和B的进行比较只要有<span class="number">1</span>那么值就为<span class="number">1</span></span><br><span class="line">     </span><br><span class="line"><span class="number">3.</span>A^B（亦或）结果：<span class="number">0011</span> <span class="number">0001</span></span><br><span class="line">解释：只要A和B的进行比较只要相同就为<span class="number">0</span>，不相同为<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>~B（取反） 结果：<span class="number">1111</span> <span class="number">0010</span></span><br><span class="line">解释：B的值为<span class="number">0</span>就取<span class="number">1</span>，为<span class="number">1</span>就取<span class="number">0</span>    </span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>&lt;&lt;(左移) *<span class="number">2</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0001</span>  <span class="number">1</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0010</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0011</span>  <span class="number">3</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0100</span>  <span class="number">4</span></span><br><span class="line"><span class="number">0000</span> <span class="number">1000</span>  <span class="number">8</span></span><br><span class="line"><span class="number">0001</span> <span class="number">0000</span>  <span class="number">16</span></span><br><span class="line"><span class="number">0010</span> <span class="number">0000</span>  <span class="number">32</span></span><br><span class="line"><span class="number">0100</span> <span class="number">0000</span>  <span class="number">64</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span>  <span class="number">128</span></span><br><span class="line">例如：<span class="number">2</span>&lt;&lt;<span class="number">3</span> </span><br><span class="line"><span class="number">0000</span> <span class="number">0010</span> （<span class="number">2</span>进制 逢<span class="number">2</span>进<span class="number">10</span>）其中<span class="number">1</span>相左移<span class="number">3</span>格就变成 <span class="number">0001</span> <span class="number">0000</span> （这个二进制在转换成十进制就是<span class="number">16</span>）</span><br><span class="line">二进制转十进制如下: </span><br><span class="line"><span class="number">0001</span> <span class="number">0000</span> </span><br><span class="line">最后一位开始：<span class="number">0</span>乘<span class="number">2</span>的<span class="number">0</span>次方为：<span class="number">0</span></span><br><span class="line">最后二位开始：<span class="number">0</span>乘<span class="number">2</span>的<span class="number">1</span>次方为：<span class="number">0</span></span><br><span class="line">最后五位开始：<span class="number">1</span>乘<span class="number">2</span>的<span class="number">4</span>次方为：<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>&gt;&gt;(右移) /<span class="number">2</span></span><br><span class="line">例如：<span class="number">128</span>&gt;&gt;<span class="number">5</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> 相右边移动五位 即：<span class="number">0000</span> <span class="number">1000</span> （转换成十进制可得：<span class="number">8</span>）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="条件运算符（三目运算符）"><a href="#条件运算符（三目运算符）" class="headerlink" title="条件运算符（三目运算符）"></a>条件运算符（三目运算符）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        System.out.println(a=<span class="number">10</span>?<span class="string">&quot;等于10&quot;</span>:<span class="string">&quot;不等于10&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展赋值运算符"><a href="#扩展赋值运算符" class="headerlink" title="扩展赋值运算符"></a>扩展赋值运算符</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="number">1.</span>+=</span><br><span class="line">        a+=b;(可以理解为：a=a+b);</span><br><span class="line">        </span><br><span class="line">        <span class="number">2.</span>-=</span><br><span class="line">        a-=b;(可以理解为：a=a-b);</span><br><span class="line">        <span class="comment">//输出结果：1020</span></span><br><span class="line">        <span class="comment">//因为前面出现字符串默认从 字符串“10”+“20”</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+a+b);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出结果：30</span></span><br><span class="line">        <span class="comment">//因为这个是先运算a+b=30，然后在进行的拼接变成了字符串“30”</span></span><br><span class="line">        System.out.println(a+b+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题：x-10-和-x-x-10-一样吗？"><a href="#问题：x-10-和-x-x-10-一样吗？" class="headerlink" title="问题：x+=10 和 x=x+10 一样吗？"></a>问题：x+=10 和 x=x+10 一样吗？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结论：不一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> x = <span class="number">10</span>;</span><br><span class="line">x = x+<span class="number">10</span>; <span class="comment">//这里编译出错 不兼容的类型，int无法转成byte，</span></span><br><span class="line">x+=<span class="number">10</span>;<span class="comment">//这里可以 等同于  x = (byte)(x+10);</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数据类型</title>
      <link href="2020/11/28/3daa4bf4.html"/>
      <url>2020/11/28/3daa4bf4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h1><table><thead><tr><th align="center"></th><th align="center">数据类型</th><th align="center">关键字</th><th align="center">内存占用</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">整数型</td><td align="center">字节型</td><td align="center">byte</td><td align="center">1个字节</td><td align="center">-128~127</td></tr><tr><td align="center"></td><td align="center">短整型</td><td align="center">short</td><td align="center">2个字节</td><td align="center">-32768~32767</td></tr><tr><td align="center"></td><td align="center">整型</td><td align="center">int</td><td align="center">4个字节</td><td align="center">-2的31次方~2的31次方-1</td></tr><tr><td align="center"></td><td align="center">长整型</td><td align="center">long</td><td align="center">8个字节</td><td align="center">-2的63次方~2的63次方-1</td></tr><tr><td align="center">浮点型</td><td align="center">单精度浮点数</td><td align="center">float</td><td align="center">4个字节</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">双精度浮点数</td><td align="center">double</td><td align="center">8个字节</td><td align="center"></td></tr><tr><td align="center">字符型</td><td align="center">字符型</td><td align="center">char</td><td align="center">2个字节</td><td align="center"></td></tr><tr><td align="center">布尔型</td><td align="center">布尔类型</td><td align="center">boolean</td><td align="center">1个字节</td><td align="center">true，false</td></tr></tbody></table><h1 id="什么是字节"><a href="#什么是字节" class="headerlink" title="什么是字节"></a>什么是字节</h1><ol><li><p>位(bit)：是计算机内部数据储存的最小单位,11001100是一个八位二进制</p></li><li><p>字节(byte)：是计算机中数据处理的基本单位,习惯上用大写B来表示,1B(byte,字节)=8bit(位)</p></li><li><p>字符：是指计算机中使用的字母、数字、字和符号</p></li><li><p>示例：</p><p> ​    1bit表示1位</p><p> ​    1Byte表示一个字节1B=8b</p><p> ​    1024B=1KB</p><p> ​    1024KB=1M</p><p> ​    1024M=1G</p></li></ol><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ol><li>范围小的类型向范围大的类型提升， byte、short、char运算时直接提升为int。</li><li>byte(2) short(2) char(2) –&gt; int(4) –&gt; long(8) –&gt; float(4) –&gt; double(8)</li><li>byte short char之间不能相互转换，它们参与运算会先转为int</li><li>布尔类型不能和其他类型相互转换</li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><ol><li><p><code>(转换类型)变量名</code></p></li><li><p><code>有高到低转换</code></p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">128</span>;</span><br><span class="line">        <span class="comment">//强制转换</span></span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</span><br><span class="line">        <span class="comment">//输出结果：-128,为什么会输出-128呢?</span></span><br><span class="line">        <span class="comment">//因为byte最大值为127,内存溢出了</span></span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><ol><li><p><code>有低到高转换</code></p><p> <code>注意点</code>：</p><ol><li><code>不能对布尔值进行转换</code></li><li><code>不能把对象类型转换成不相干的类型</code></li><li><code>在把高容量转换到低容量的时候，强制转换</code></li><li><code>转换的时候可能存在内存溢出或者精度丢失问题</code></li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">128</span>;</span><br><span class="line">        <span class="comment">//字段转换</span></span><br><span class="line">        <span class="keyword">double</span> b = i;</span><br><span class="line">        <span class="comment">//输出结果：128.0</span></span><br><span class="line">        <span class="comment">//因为转成double类型了</span></span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存溢出问题"><a href="#内存溢出问题" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h2><ol><li><p><code>操作比较大的数的时候，注意溢出问</code></p></li><li><p><code>JDK7新特性,数字之间可以用下划线分割表示</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> money = <span class="number">10_0000_0000</span>;</span><br><span class="line">        <span class="keyword">int</span> years = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> total = money * years;</span><br><span class="line">        <span class="comment">//输出结果：-1474836480</span></span><br><span class="line">        <span class="comment">//因为值已经溢出了</span></span><br><span class="line">        System.out.println(total);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> total2 = money * years;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//输出结果：-1474836480</span></span><br><span class="line">        <span class="comment">//因为money和years默认为int类型,这里已经出现问题,所以它们相乘也是一个int类型的数字</span></span><br><span class="line">        System.out.println(total2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> total3 = money * ((<span class="keyword">long</span>)years);</span><br><span class="line">        <span class="comment">//输出结果：200_0000_0000</span></span><br><span class="line">        System.out.println(total3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="数据类型拓展"><a href="#数据类型拓展" class="headerlink" title="数据类型拓展"></a>数据类型拓展</h1><h2 id="整数拓展"><a href="#整数拓展" class="headerlink" title="整数拓展"></a>整数拓展</h2><p><code>进制 二进制(0b开头) 十进制 八进制(0) 十六进制(0x)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">010</span>; <span class="comment">//八进制0(逢10进8)</span></span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">0x10</span>; <span class="comment">//十六进制0x 0~9 A~F 16(逢16进10)</span></span><br><span class="line">        System.out.println(i);<span class="comment">//输出结果10</span></span><br><span class="line">        System.out.println(i2);<span class="comment">//输出结果8</span></span><br><span class="line">        System.out.println(i3);<span class="comment">//输出结果16</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点数拓展"><a href="#浮点数拓展" class="headerlink" title="浮点数拓展"></a>浮点数拓展</h2><p><code>浮点数是有舍入误差的,接近但是不等于</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> f = <span class="number">0.1f</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">0.1</span>;</span><br><span class="line">        System.out.println(f==d);<span class="comment">//输出false,f不等于d</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">float</span> f1 = <span class="number">214121231f</span>;</span><br><span class="line">        <span class="keyword">float</span> f2 = f1+<span class="number">1</span>;</span><br><span class="line">        System.out.println(f1==f2);<span class="comment">//输出true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符拓展"><a href="#字符拓展" class="headerlink" title="字符拓展"></a>字符拓展</h2><p><code>所有的字符本质都是数字</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">char</span> c2 = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        System.out.println(c1);<span class="comment">//输出结果：A</span></span><br><span class="line">        <span class="comment">//(int)c1 强制转换</span></span><br><span class="line">        System.out.println((<span class="keyword">int</span>)c1);<span class="comment">//输出结果：65</span></span><br><span class="line">        System.out.println(c2);<span class="comment">//输出结果：中</span></span><br><span class="line">        System.out.println((<span class="keyword">int</span>)c2);<span class="comment">//输出结果：20013</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EMQX配置wss</title>
      <link href="2020/11/27/a464dc8f.html"/>
      <url>2020/11/27/a464dc8f.html</url>
      
        <content type="html"><![CDATA[<h1 id="MQTT协议介绍"><a href="#MQTT协议介绍" class="headerlink" title="MQTT协议介绍"></a>MQTT协议介绍</h1><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p><p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用</p><p>此处跳过安装过程！！</p><h1 id="1-emqx-conf"><a href="#1-emqx-conf" class="headerlink" title="1. emqx.conf"></a>1. emqx.conf</h1><p>emqx.conf 默认是在 /etc/ 目录下的</p><p>emqx.conf就修改<code>listener.wss.external.keyfile</code>,<code>listener.wss.external.certfile</code> 其他默认保存就可以了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Path to the file containing the user&#39;s private PEM-encoded key.</span><br><span class="line">##</span><br><span class="line">## See: listener.ssl.$name.keyfile</span><br><span class="line">##</span><br><span class="line">## Value: File</span><br><span class="line"># 此处修改自己证书密钥的路径</span><br><span class="line">listener.wss.external.keyfile &#x3D; &#x2F;etc&#x2F;emqx&#x2F;certs&#x2F;key.pem</span><br><span class="line">## Path to a file containing the user certificate.</span><br><span class="line">##</span><br><span class="line">## See: listener.ssl.$name.certfile</span><br><span class="line">##</span><br><span class="line">## Value: File</span><br><span class="line"># 此处修改自己证书的路径</span><br><span class="line">listener.wss.external.certfile &#x3D; &#x2F;etc&#x2F;emqx&#x2F;certs&#x2F;cert.pem</span><br></pre></td></tr></table></figure><p>证书申请可以参考：<a href="https://blog.myiszhb.cn/2020/11/26/733eea1c.html">certbot白嫖https证书</a></p><h1 id="2-重启"><a href="#2-重启" class="headerlink" title="2. 重启"></a>2. 重启</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart emqx</span><br></pre></td></tr></table></figure><h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h1><p>emqx 默认地址是ip:18083<br>emqx 默认账号: admin 密码:public</p><p>这是ws的</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201127144042.png" alt="@VB5UN8R03T(~3LC40}YH}P"></p><p>这是wss的</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201127144132.png"></p><p>自此emqx的wss就完成了</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emqx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>certbot白嫖https证书</title>
      <link href="2020/11/26/733eea1c.html"/>
      <url>2020/11/26/733eea1c.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-certbot安装"><a href="#1-certbot安装" class="headerlink" title="1.certbot安装"></a>1.certbot安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget https:&#x2F;&#x2F;dl.eff.org&#x2F;certbot-auto</span><br><span class="line">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure><h1 id="2-认证方式"><a href="#2-认证方式" class="headerlink" title="2.认证方式"></a>2.认证方式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dns-01：给域名添加一个 DNS TXT 记录。</span><br><span class="line">http-01：在域名对应的 Web 服务器下放置一个 HTTP well-known URL 资源文件。</span><br><span class="line">tls-sni-01：在域名对应的 Web 服务器下放置一个 HTTPS well-known URL 资源文件。</span><br></pre></td></tr></table></figure><h1 id="3-申请证书"><a href="#3-申请证书" class="headerlink" title="3. 申请证书"></a>3. 申请证书</h1><p>这里<code>myiszhb.cn</code> 域名最好加是<code>xxx.myiszhb.cn</code>这样才是受信任的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;certbot-auto certonly  -d *.myiszhb.cn  --manual --preferred-challenges dns --server https:&#x2F;&#x2F;acme-v02.api.letsencrypt.org&#x2F;directory </span><br></pre></td></tr></table></figure><p>参数简介</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certonly，表示安装模式，Certbot 有安装模式和验证模式两种类型的插件。</span><br><span class="line">--manual  表示手动安装插件，Certbot 有很多插件，不同的插件都可以申请证书，用户可以根据需要自行选择</span><br><span class="line">-d 为那些主机申请证书，如果是通配符，输入 *.newyingyong.cn（可以替换为你自己的域名）</span><br><span class="line">--preferred-challenges dns，使用 DNS 方式校验域名所有权</span><br><span class="line">--server，Let&#39;s Encrypt ACME v2 版本使用的服务器不同于 v1 版本，需要显示指定。</span><br></pre></td></tr></table></figure><h1 id="4-交互界面"><a href="#4-交互界面" class="headerlink" title="4.交互界面"></a>4.交互界面</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Saving debug log to &#x2F;var&#x2F;log&#x2F;letsencrypt&#x2F;letsencrypt.log</span><br><span class="line">Plugins selected: Authenticator manual, Installer None</span><br><span class="line">Enter email address (used for urgent renewal and security notices) (Enter &#39;c&#39; to</span><br><span class="line">cancel): xxx@163.com</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Please read the Terms of Service at</span><br><span class="line">https:&#x2F;&#x2F;letsencrypt.org&#x2F;documents&#x2F;LE-SA-v1.2-November-15-2017.pdf. You must</span><br><span class="line">agree in order to register with the ACME server at</span><br><span class="line">https:&#x2F;&#x2F;acme-v02.api.letsencrypt.org&#x2F;directory</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(A)gree&#x2F;(C)ancel: A</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Would you be willing to share your email address with the Electronic Frontier</span><br><span class="line">Foundation, a founding partner of the Let&#39;s Encrypt project and the non-profit</span><br><span class="line">organization that develops Certbot? We&#39;d like to send you email about our work</span><br><span class="line">encrypting the web, EFF news, campaigns, and ways to support digital freedom.</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(Y)es&#x2F;(N)o: Y</span><br><span class="line"></span><br><span class="line">Obtaining a new certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">dns-01 challenge for archerwong.cn</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">NOTE: The IP of this machine will be publicly logged as having requested this</span><br><span class="line">certificate. If you&#39;re running certbot in manual mode on a machine that is not</span><br><span class="line">your server, please ensure you&#39;re okay with that.</span><br><span class="line"></span><br><span class="line">Are you OK with your IP being logged?</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(Y)es&#x2F;(N)o: (Y)es&#x2F;(N)o: Y</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Please deploy a DNS TXT record under the name</span><br><span class="line">_acme-challenge.myiszhb.cn with the following value:</span><br><span class="line"></span><br><span class="line">UCSGGMLKXQ7BKZ3XOb-wLUM8yvEI4BGt-86waMxnJJ3</span><br><span class="line"></span><br><span class="line">Before continuing, verify the record is deployed.</span><br><span class="line">- - - - - - - - - - - - - - - - -</span><br></pre></td></tr></table></figure><p>自此证书就申请完毕了</p><p>如需自动续费参考：<a href="https://www.cnblogs.com/redirect/p/10140254.html">https://www.cnblogs.com/redirect/p/10140254.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> certbot </tag>
            
            <tag> 证书 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
