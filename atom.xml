<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七月のBlog</title>
  
  
  <link href="https://blog.myiszhb.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.myiszhb.cn/"/>
  <updated>2020-12-16T13:19:41.228Z</updated>
  <id>https://blog.myiszhb.cn/</id>
  
  <author>
    <name>七月</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集合</title>
    <link href="https://blog.myiszhb.cn/2020/12/16/d366874c.html"/>
    <id>https://blog.myiszhb.cn/2020/12/16/d366874c.html</id>
    <published>2020-12-16T12:57:55.000Z</published>
    <updated>2020-12-16T13:19:41.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是集合？有什么用？"><a href="#什么是集合？有什么用？" class="headerlink" title="什么是集合？有什么用？"></a>什么是集合？有什么用？</h1><ol><li>数组其实就是一个集合。集合实际上就是一个容器，可以来容纳其他类型的数据。</li><li>集合不能直接存储基本数据类型，另外集合也不能直接存储Java对象。集合当作存储的都是Java对象的内存地址(引用)。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line">    集合在Java中本身就是一个容器，是一个对象。</span><br><span class="line">    集合中任何时候存储的都是引用。</span><br><span class="line"></span><br><span class="line">list.add(100);&#x2F;&#x2F;属于自动装箱Integer,属于对象</span><br></pre></td></tr></table></figure></li><li>在Java中每一个不同的集合，底层会对应不同的数据结果。往不同的集合中存储元素，等于往不同的数据结构中存储。</li><li>在Java中集合分为两大类：<ol><li>一类是单个方式存储元素，这一类集合的super父接口：java.util.Collection。</li><li>一类是以键值对方式存储元素，这一类集合的super父接口：java.util.Map。</li></ol></li></ol><h1 id="集合的继承结构"><a href="#集合的继承结构" class="headerlink" title="集合的继承结构"></a>集合的继承结构</h1><h2 id="list和set"><a href="#list和set" class="headerlink" title="list和set"></a>list和set</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216210150.png" alt="image"></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216210242.png" alt="image"></p><h2 id="所有集合的实现类"><a href="#所有集合的实现类" class="headerlink" title="所有集合的实现类"></a>所有集合的实现类</h2><ol><li>ArrayList: 底层是数组。</li><li>LinkedList: 底层是双向链表。</li><li>Vector: 底层是数组，线程安全的，效率较低。</li><li>HashSet: 底层是HashMap，放在HashSet集合中的元素等同于放在了HasgMap集合的key部分。</li><li>TreeSet: 底层是TreeMap，放在TreeSet集合中的元素等同于放在了TreeMap集合的key部分。</li><li>HashMap: 底层是哈希表</li><li>HashTable: 底层也是哈希表，只不过线程安全的，效率较低。</li><li>Properties: 是线程安全的，并且key和value只能存储字符串String。</li><li>TreeMap: 底层是二叉树，TreeMap集合的key可以自动按照大小顺序排序。</li></ol><h2 id="List存储集合元素的特点"><a href="#List存储集合元素的特点" class="headerlink" title="List存储集合元素的特点"></a>List存储集合元素的特点</h2><ol><li>有序可重复。  <ol><li>有序：<br> 存进去的顺序和取出来的顺序相同，每一个元素都有下标。</li><li>可重复：<br> 存进去1，可以在存储一个1。</li></ol></li></ol><h2 id="Set-Map-存储集合元素的特点"><a href="#Set-Map-存储集合元素的特点" class="headerlink" title="Set(Map)存储集合元素的特点"></a>Set(Map)存储集合元素的特点</h2><ol><li>无序不可重复<ol><li>无序：<br> 存进去的顺序和取出来的顺序不一定相同，另外Set集合没有下标。</li><li>不可重复：<br> 存进去1，不能在存储一个1。</li></ol></li></ol><h2 id="SortedSet-SortedMap-存储集合元素的特点"><a href="#SortedSet-SortedMap-存储集合元素的特点" class="headerlink" title="SortedSet(SortedMap)存储集合元素的特点"></a>SortedSet(SortedMap)存储集合元素的特点</h2><ol><li>首先是无序不可重复的，但是SortedSet集合中的元素是可排序的<ol><li>无序：<br> 存进去的顺序和取出来的顺序不一定相同，另外Set集合没有下标。</li><li>不可重复：<br> 存进去1，不能在存储一个1。</li><li>可排序：<br> 按照大小顺序排序。</li></ol></li></ol><blockquote><p>备注：Map集合的key，就是一个Set集合。往Set集合中放数据，实际上放到了Map的key部分</p></blockquote><h1 id="Collection-常用的方法"><a href="#Collection-常用的方法" class="headerlink" title="Collection 常用的方法"></a>Collection 常用的方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 关于Java.util.Collection接口的常用方法。</span></span><br><span class="line"><span class="comment"> 1.Collection中能存放什么元素？</span></span><br><span class="line"><span class="comment">    没有使用“泛型”，Collection中可以存储Object的所有类型，</span></span><br><span class="line"><span class="comment">    使用了“泛型”之后，Collection只能存储对于泛型的数据</span></span><br><span class="line"><span class="comment"> 2。Collection常用方法</span></span><br><span class="line"><span class="comment">    1. boolean add(Object e) 向集合添加元素</span></span><br><span class="line"><span class="comment">    2. int size() 获取集合中的元素个数</span></span><br><span class="line"><span class="comment">    3. void clear() 清空集合元素</span></span><br><span class="line"><span class="comment">    4. boolean contains(Object e) 判断集合里面是否包含某个元素</span></span><br><span class="line"><span class="comment">    5. boolean remove(Object e) 删除集合中的某个元素</span></span><br><span class="line"><span class="comment">    6. boolean isEmpty() 判断集合元素个数是否为0</span></span><br><span class="line"><span class="comment">    7. Object[] toArray() 将集合转换成数组</span></span><br><span class="line"><span class="comment">    8. Iterator iterator() 获取集合对象的迭代器对象Iterator</span></span><br><span class="line"><span class="comment">        以下两个方法时迭代器对象Iterator中的方法：</span></span><br><span class="line"><span class="comment">            boolean hasNext() 如果仍有元素可以叠，则返回true</span></span><br><span class="line"><span class="comment">            Object next() 返回迭代的下一个元素</span></span><br><span class="line"><span class="comment">        注意：此时获取的迭代器，指向的是那个集合中没有元素的状态下的迭代器</span></span><br><span class="line"><span class="comment">        注意：集合结果只要发生改变，迭代器必须重写获取</span></span><br><span class="line"><span class="comment">        注意：在集合元素迭代的时候不能调用remove方法。不能调用集合的remove方法，可以调用迭代器的remove方法，因为调用集合的remove方法 它不会通知迭代器，而调用迭代器的remove方法，它会删除集合以及迭代器的元素。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         接口时抽象的，无法实例化</span></span><br><span class="line"><span class="comment">         Collection collection = new Collection();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//多态</span></span><br><span class="line">        Collection c =  <span class="keyword">new</span> ArrayList();</span><br><span class="line">        c.add(<span class="number">100</span>);<span class="comment">//自动装箱机制，实际上时放进去了一个对象的内存地址。Integer integer = new Integer(100)</span></span><br><span class="line">        c.size();</span><br><span class="line">        c.clear();</span><br><span class="line">        c.contains(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        c.remove(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        c.isEmpty();</span><br><span class="line">        Object[] objects = c.toArray();</span><br><span class="line">        <span class="comment">//注意：此时获取的迭代器，指向的是那个集合中没有元素的状态下的迭代器</span></span><br><span class="line">        <span class="comment">//集合结果只要发生改变，迭代器必须重写获取</span></span><br><span class="line">        Iterator iterator = c.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object o = iterator.next();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Map接口中常用方法"><a href="#Map接口中常用方法" class="headerlink" title="Map接口中常用方法"></a>Map接口中常用方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Map</span></span><br><span class="line"><span class="comment">    1. Map和Collection没有集成关系。</span></span><br><span class="line"><span class="comment">    2. Map集合以key和value的方式存储数据：键值对</span></span><br><span class="line"><span class="comment">        key和value都是引用数据类型。</span></span><br><span class="line"><span class="comment">        key和value都是存储对象的内存地址。</span></span><br><span class="line"><span class="comment">        key起到主导第地位，value是key的一个附属品。</span></span><br><span class="line"><span class="comment">    3. Map接口中常用方法：</span></span><br><span class="line"><span class="comment">        V put(K key,V value) 向Map集合中添加键值对</span></span><br><span class="line"><span class="comment">        V get(Object key) 通过key查询value</span></span><br><span class="line"><span class="comment">        void clear() 清空Map集合</span></span><br><span class="line"><span class="comment">        boolean containsKey(Object key) 判断Map集合是否包含key</span></span><br><span class="line"><span class="comment">        boolean containsVlaue(Object value) 判断Map集合是否包含value</span></span><br><span class="line"><span class="comment">        boolean isEmpty() 判断Map集合中元素个数是否为0（为空）</span></span><br><span class="line"><span class="comment">        Set&lt;K&gt; keySet() 获取Map集合所有的key（所有的键是一个set集合）</span></span><br><span class="line"><span class="comment">        V remove(Object key) 通过key删除Map集合中的元素</span></span><br><span class="line"><span class="comment">        int size() 获取Map集合的个数</span></span><br><span class="line"><span class="comment">        Collection&lt;V&gt; values() 获取Map集合中所有的value，返回一个Collection</span></span><br><span class="line"><span class="comment">        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 将Map集合转换成Set集合</span></span><br><span class="line"><span class="comment">            假设： map 集合对象的</span></span><br><span class="line"><span class="comment">                 key  value</span></span><br><span class="line"><span class="comment">                 1    zhangsan</span></span><br><span class="line"><span class="comment">             -------------------------------</span></span><br><span class="line"><span class="comment">             转换后： Set set = map.entrySet();</span></span><br><span class="line"><span class="comment">                1=zhangsan  (这是一个值)</span></span><br><span class="line"><span class="comment">             备注：Map集合调用entrySet()方法得到set集合类型是Map.Entry类型的，</span></span><br><span class="line"><span class="comment">             Map.Entry和String一样，都是一种类型的名字，不过Map.Entry是静态内部类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历Map的3种方式</span></span><br><span class="line">        <span class="comment">//1.foreach 先获取所有的key</span></span><br><span class="line">        Set&lt;Integer&gt; integers = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">            System.out.println(integer+<span class="string">&quot;=&quot;</span>+map.get(integer));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 通过entrySet()方法转换成set集合 遍历</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : set) &#123;</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">&quot;=&quot;</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 通过entrySet()方法转换成set集合,在转换成迭代器,遍历迭代器</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set1 = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = set1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; next = iterator.next();<span class="comment">//这里的Map.Entry 实际上就是一个node</span></span><br><span class="line">            System.out.println(next.getKey()+<span class="string">&quot;=&quot;</span>+next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="List-常用方法"><a href="#List-常用方法" class="headerlink" title="List 常用方法"></a>List 常用方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> List集合存储元素的特点：有序可重复</span><br><span class="line">    <span class="number">1.1</span> 有序，指List集合中的元素有下标。从<span class="number">0</span>开始，依次递增</span><br><span class="line">    <span class="number">1.2</span> 可重复，存储一个<span class="number">1</span>，还可以在存储一个<span class="number">1.</span></span><br><span class="line"><span class="number">2.</span> List既然是Collection接口的子接口，肯定List接口有自己特色的常用方法：</span><br><span class="line">    <span class="number">2.1</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,Object element)</span> 添加元素</span></span><br><span class="line"><span class="function">    2.2 Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> 根据下标取元素</span></span><br><span class="line"><span class="function">    2.3 <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> 获取指定元素第一次出现的索引</span></span><br><span class="line"><span class="function">    2.4 <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> 获取指定元素最后一次出现的索引</span></span><br><span class="line"><span class="function">    2.5 Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> 通过索引删除元素</span></span><br><span class="line"><span class="function">    2.6 Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,Object element)</span> 往指定索引添加元素</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><code>总结</code></h1><blockquote><p>ArrayList</p></blockquote><ol><li><p>有序可重复</p></li><li><p>List的初始化容量为10（底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10）。</p></li><li><p>ArryList集合底层是Object[]数组`。</p></li><li><p>ArryList集合扩容容量是(旧容量+旧容量&gt;&gt;1)，扩容原数组的1.5倍。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">    旧容量 = <span class="number">10</span>;</span><br><span class="line">    扩容之后: <span class="number">10</span> + (<span class="number">10</span>&gt;&gt;<span class="number">1</span>) = <span class="number">15</span></span><br><span class="line">    解析：<span class="number">10</span> 的二进制 <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">    右移后：<span class="number">0000</span> <span class="number">0101</span> 的十进制 <span class="number">4</span>+<span class="number">1</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line">add扩容底层源码</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//旧的容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//扩容后的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//copy数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ArrayList集合非线程安全</p></li><li><p>ArryList的优点：检索效率比较高（因为底层是数组，数组的检索效率高，但是增删操作效率低）。</p></li><li><p>ArryList的缺点：随机增删元素效率较低，但是在末尾增删效率不变。</p></li></ol><blockquote><p>LinkedList</p></blockquote><ol><li>LinkedList集合底层也有下标。</li><li>LinkedList集合没有初始化容量。</li><li>LinkedList集合底层是双向链表。</li><li>LinkedList的优点：由于链表上的元素空间存储地址不连续，所以随机增删元素的时候不会有大量元素位移，因此随机增删效率高</li><li>LinkedList的缺点：不能通过数学表达式查找元素的内存地址，每一次都需要从头节点开始遍历，直到找到为止，所以检索效率较低。</li><li>LinkedList非线程安全。</li><li>有序可重复。</li></ol><blockquote><p>Vector</p></blockquote><ol><li>Vector集合底层也是一个数组。</li><li>Vector集合底层初始容量为10。</li><li>Vector集合的扩容,扩容数后时原数组的2倍大小。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">备注：</span><br><span class="line">    java.utls.Collection 是接口</span><br><span class="line">    java.utls.Collections 是工具类 里面封装了方法用于集合操作</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> var2 = <span class="keyword">this</span>.elementData.length;</span><br><span class="line">    <span class="comment">//capacityIncrement一直为0;</span></span><br><span class="line">    <span class="comment">//数组长度+ （初始长度&gt;0?初始长度：数组长度）</span></span><br><span class="line">    <span class="comment">//默认扩容var2+var2;</span></span><br><span class="line">    <span class="keyword">int</span> var3 = var2 + (<span class="keyword">this</span>.capacityIncrement &gt; <span class="number">0</span> ? <span class="keyword">this</span>.capacityIncrement : var2);</span><br><span class="line">    <span class="keyword">if</span> (var3 - var1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        var3 = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (var3 - <span class="number">2147483639</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        var3 = hugeCapacity(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.elementData = Arrays.copyOf(<span class="keyword">this</span>.elementData, var3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Vector集合线程安全，都带有synchronized关键字修饰，效率较低。</li><li>有序可重复。</li></ol><blockquote><p>HashSet</p></blockquote><ol><li>无序不可重复（无序：存进去的顺序和取出来的顺序不同）</li><li>放到HsahSet集合的元素实际是存放到HashMap集合的key部分。</li><li>HashSet集合非线程安全。</li></ol><blockquote><p>HashMap</p></blockquote><ol><li><p>HashMap集合底层是哈希表/散列表的数据结构。  </p></li><li><p>哈希表是一个怎么样的数据结构呢？<br> 哈希表是一个数组和单向链表的结合体。<br> 数组：在查询方面效率很高，随机增删方面效率很低。<br> 单向链表：在查询方法效率低，随机增删方法效率高。<br> 哈希表将数组、单向链表两种数据结构融合在一起，充分发挥它们各自的优点。</p></li><li><p>HashMap集合底层的源代码 </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span></span>&#123;</span><br><span class="line">    <span class="comment">//HashMap底层实际上就是一个数组。</span></span><br><span class="line">    Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">//静态的内部类HashMap.Node</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//哈希值（哈希值是key通过hashCode()方法的执行结构,hash值通过哈希函数/算法,可转换成数组的下标）</span></span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">//存储的Map集合中的key</span></span><br><span class="line">        V value; <span class="comment">//存储到Map集合中的value</span></span><br><span class="line">        Node&lt;K,V&gt; next; <span class="comment">//下一个节点的内存地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HashMap集合key的部分特点<br> 无序：存进去和取出来的顺序不同,所以无序。<br> 不可重复：因为底层采用了equals方法来保证HashMap集合的key不可重复,如果可以重复了,value的值会被直接覆盖。<br> HashMap是非线程安全的。<br> 放在HashMap集合key部分的元素其实就是放在了HashSet集合中了。<br> 所以HashSet集合中的元素也需要同时重写hashCode()和equals()方法。</p></li><li><p>哈希表HashMap使用不当时无法发挥性能<br> 我们要保证散列分布均匀，那什么是散列分布均匀呢？  </p><pre><code> 假设有100个元素，10个单向链表，那么么个单向链表上有10个节点，这是最好的，是散列分布均匀的。</code></pre></li><li><p>重点<br> 放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写hashCode()和equals()方法。</p></li><li><p>HashMap集合默认初始容量是16,默认加载因子是0.75f，扩容后的容量是原容量的2倍 。<br> 这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候,数组开始扩容。<br> 重点：HashMap初始容量必须是2的倍数,这是官方推荐的,这样能达到散列均匀,为了提高HashMap集合的存储效率。</p></li><li><p>JDK1.8之后HashMap中哈希表单向链表的数量超过8个就会换成红黑树结构,如果数量小于6就会转换成单向链表结构。</p></li><li><p>map.put(k,v)实现原理<br>第一步：先将k,v封装到Node对象当中。<br>第二步：底层会调用k的hashCode()方法得到hash值,然后通过哈希函数/哈希算法，<br>将hash值转换成数组的下标,下标位置上如果没有任何元素,就把Node添加到这个位置<br>上,如果说下标对于的位置上有链表(Node),此时会拿着k和链表上每一个节点中的k进<br>行equals比较,如果所有的equals方法返回false,那么这个节点将被添加到链表的末<br>尾,如果其中一个equals返回了true,那么这个节点的value将会被覆盖。</p></li><li><p>map.get(k)实现原理<br>先调用k的hansCode()方法得到哈希值,通过哈希算法转换成数组下标,通过数组下标<br>快速找到对应位置上，如果这个位置上面都没有,返回null。如果这个节点上有单向链<br>表(Node),那么会拿着参数k和单向链表上的每个节点中的k进行equals比较,如果所<br>有的equals都返回false,那么get方法返回null。只要其中一个节点返回true,那<br>么此时就会把这个节点上的value,返回回去。</p></li></ol><blockquote><p>HashTable</p></blockquote><ol><li>HashTable集合的底层也是哈希表/散列表结构。</li><li>HashTable集合的初始化容量是11，默认加载因子也是0.75f,扩容量是：(原长度*2)+1</li></ol><blockquote><p>Properties</p></blockquote><ol><li>Properties是一个Map集合，继承HashTable，properties是key和value都是String类型的。</li><li>Properties被称为属性对象。</li><li>Properties是线程安全的。</li></ol><blockquote><p>TreeSet</p></blockquote><ol><li><p>TreeSet集合底层实际上是一个TreeMap</p></li><li><p>TreeMap集合底层是一个二叉树</p></li><li><p>放在TreeSet集合中的元素，等同于放在TreeMap的key部分</p></li><li><p>TreeSet集合中的元素 无序不可重复，但是可以按照元素的大小顺序真的排序，称为：可排序集合。</p></li><li><p>TreeSet集合非线程安全。</p></li><li><p>TreeSet集如果存入自定义对象，自定义对象必须实现Comparable&lt;&gt;接口<br> TreeMap底层源码是先判断有无比较器的。<br> Comparable和Comparator怎么选择？</p><pre><code> 1. 比较规则经常发生改变时，使用Comparator，Comparator接口符合OCP原则。   2. 比较规则不会发生变动时，使用Comparable。</code></pre><p> 方式1：实现java.long.Comparable接口,并重写其compareTo方法。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    User对象按照年龄排序</span></span><br><span class="line"><span class="comment">    如果年龄一样就按照name排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="number">20</span>,<span class="string">&quot;三毛&quot;</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">30</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        User user3 = <span class="keyword">new</span> User(<span class="number">18</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        User user4 = <span class="keyword">new</span> User(<span class="number">20</span>,<span class="string">&quot;阿珂&quot;</span>);</span><br><span class="line">        Set set = <span class="keyword">new</span> TreeSet&lt;User&gt;();</span><br><span class="line">        set.add(user1);</span><br><span class="line">        set.add(user2);</span><br><span class="line">        set.add(user3);</span><br><span class="line">        set.add(user4);</span><br><span class="line">        <span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点：TreeSet存入自定义对象必须重写Comparable接口,并实现其compareTo方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;User&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;age=&quot;</span>).append(age);</span><br><span class="line">        sb.append(<span class="string">&quot;, name=&#x27;&quot;</span>).append(name).append(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        compareTo方法的返回值很重要：</span></span><br><span class="line"><span class="comment">            返回0表示相同，value会覆盖。</span></span><br><span class="line"><span class="comment">            返回&gt;0，会继续在右子树上找。（10-9=1，1&gt;0 说明左边这个数字比较大，所以在右子树上找）</span></span><br><span class="line"><span class="comment">            返回&lt;0，会继续在左子树上找。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.age == o.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> o.getName().compareTo(<span class="keyword">this</span>.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.age-o.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 方式2：创建一个比较器实现java.utls.Comparator接口，并重写的compare方法，然后创建TreeSet集合的时候传入进去</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="number">20</span>,<span class="string">&quot;三毛&quot;</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">30</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        User user3 = <span class="keyword">new</span> User(<span class="number">18</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        User user4 = <span class="keyword">new</span> User(<span class="number">20</span>,<span class="string">&quot;阿珂&quot;</span>);</span><br><span class="line">        Set set = <span class="keyword">new</span> TreeSet&lt;User&gt;(<span class="keyword">new</span> UserComparator());</span><br><span class="line">        <span class="comment">//或者使用匿名内部类</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Set set = new TreeSet&lt;User&gt;(new Comparator&lt;User&gt;()&#123;</span></span><br><span class="line"><span class="comment">                 public int compare(User o1, User o2) &#123;</span></span><br><span class="line"><span class="comment">                    if(o1.getAge() == o2.getAge())&#123;</span></span><br><span class="line"><span class="comment">                        return o2.getName().compareTo(o1.getName());</span></span><br><span class="line"><span class="comment">                    &#125;else&#123;</span></span><br><span class="line"><span class="comment">                        return o1.getAge()-o2.getAge();</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        set.add(user1);</span><br><span class="line">        set.add(user2);</span><br><span class="line">        set.add(user3);</span><br><span class="line">        set.add(user4);</span><br><span class="line">        <span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;User&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;age=&quot;</span>).append(age);</span><br><span class="line">        sb.append(<span class="string">&quot;, name=&#x27;&quot;</span>).append(name).append(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建比较器实现compare方法，写判断规则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User o1, User o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o1.getAge() == o2.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> o2.getName().compareTo(o1.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Collection的方法：-boolean-contains-Object-e"><a href="#Collection的方法：-boolean-contains-Object-e" class="headerlink" title="Collection的方法： boolean contains(Object e)"></a>Collection的方法： boolean contains(Object e)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        c.add(s1);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        c.add(s2);</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">//这里返回true为什么？？</span></span><br><span class="line">        <span class="comment">//因为底层代码调用了equals方法比较，而这个内容又是String的，string时重写了equals方法的，所以比较这里比较的时内容，而不是引用。</span></span><br><span class="line">        System.out.println(c.contains(s3));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//源码分析</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//这里调用equals进行比较</span></span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存分析图：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216210311.png" alt="image"></p><h2 id="Collection的方法：boolean-remove-Object-o"><a href="#Collection的方法：boolean-remove-Object-o" class="headerlink" title="Collection的方法：boolean remove(Object o)"></a>Collection的方法：boolean remove(Object o)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(s1);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.remove(s2);</span><br><span class="line">        <span class="comment">//输出结果0,因为remove方法的底层也调用了equals去比较，String类型底层代码重写了equals方法，比较值</span></span><br><span class="line">        System.out.println(c.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//源码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123; <span class="comment">//测出调用了equals方法</span></span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  如果类重写了equals方法：<br>       contains就包含<br>       equals就可以删除<br>   如果不重写equals方法，它会默认取调用Object的equals方法，默认==比较，比较引用<br>       contains就不包含<br>       equals就不可删除  </p></blockquote><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="单向链表结构"><a href="#单向链表结构" class="headerlink" title="单向链表结构"></a>单向链表结构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216210340.png" alt="image"></p><h2 id="哈希表-散列表结构-Map"><a href="#哈希表-散列表结构-Map" class="headerlink" title="哈希表/散列表结构 Map"></a>哈希表/散列表结构 Map</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216210409.png" alt="image"></p><h2 id="自平衡二叉树-TreeMap就是"><a href="#自平衡二叉树-TreeMap就是" class="headerlink" title="自平衡二叉树 TreeMap就是"></a>自平衡二叉树 TreeMap就是</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/my-zhb/CDN/img/20201216210429.png" alt="image"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a><code>问题</code></h1><blockquote><p>1.HashMap集合key部分允许为null吗？  </p></blockquote><p>允许，但是HashMap集合的key，null值只能有一个。<br>HashMap集合的key和value都允许为null;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//这里输出1,说明HashMap的key部分可以为null</span></span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        map.put(<span class="keyword">null</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//也可以通过null来进行查询,结果为100</span></span><br><span class="line">        System.out.println(map.get(<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.HashTable的key可以为null吗？  </p></blockquote><p>HashTable的key河value都不能为空。</p><blockquote><p>3.HashMap和HashTable的区别？  </p></blockquote><ol><li>HashMap线程不安全,HashTable线程安全</li><li>HashMap的key和value都可以为null,HashTable的key和value不允许为null.</li></ol>]]></content>
    
    
    <summary type="html">集合</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="集合" scheme="https://blog.myiszhb.cn/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>包装类</title>
    <link href="https://blog.myiszhb.cn/2020/12/14/52c58cb2.html"/>
    <id>https://blog.myiszhb.cn/2020/12/14/52c58cb2.html</id>
    <published>2020-12-14T12:24:34.000Z</published>
    <updated>2020-12-14T12:34:49.808Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java中为8种基本数据类型准备了8种包装类型。8种包装类型都属于引用类型。</span><br><span class="line">思考：为什么需要再提供8种包装类型呢？</span><br><span class="line">    因为8种基本数据类型不够用，所以SUN又提供了8种包装类型。</span><br></pre></td></tr></table></figure><h1 id="Java中对每种基本类型都有一个对应的包装类"><a href="#Java中对每种基本类型都有一个对应的包装类" class="headerlink" title="Java中对每种基本类型都有一个对应的包装类"></a>Java中对每种基本类型都有一个对应的包装类</h1><ul><li>byte -&gt; Byte 继承number</li><li>short -&gt; Short 继承number</li><li>int -&gt; Integer 继承number</li><li>long -&gt; Long 继承number</li><li>float -&gt; Float 继承number</li><li>double -&gt; Double 继承number</li><li>boolean -&gt; Boolean 继承Object</li><li>char -&gt; Character  继承Object</li></ul><h1 id="什么是包装类？"><a href="#什么是包装类？" class="headerlink" title="什么是包装类？"></a>什么是包装类？</h1><p>Java种的基本数据类型并不制裁面向对象编程，不具备“对象”的特征，不携带属性、没有方法可以调用，无法提供向上转型取到Object提供的方法。个人理解：就是把基本数据类型封装成对象，有属性，有方法，更能利于开发。</p><h1 id="基本数据类型和包装类的区别？"><a href="#基本数据类型和包装类的区别？" class="headerlink" title="基本数据类型和包装类的区别？"></a>基本数据类型和包装类的区别？</h1><ol><li>定义不同。包装类属于对象，基本数据类型不是。</li><li>声明和使用方式不同，包装类使用new初始化，有些集合类的定义不能使用基本数据类型，例如 ArrayList<Integer></li><li>初始值不同。包装类默认值为null，基本数据类型则不同的类型值不一样</li><li>存储方式和位置不同，从而性能不同。基本数据类型存储在栈(stack)中，包装类则分成引用和实列，引用在栈(stack)中，具体实例在推(heap)中。</li></ol><h1 id="什么是装箱与拆箱？"><a href="#什么是装箱与拆箱？" class="headerlink" title="什么是装箱与拆箱？"></a>什么是装箱与拆箱？</h1><p>将基本数据类型变为包装器类，便是装箱，将包装器类转为基本数据类型就是拆箱</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//手动装箱</span></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"><span class="comment">// 拆箱（floatValue是number的方法，number是基本数据类型的父类除了boolean和char，基本数据类型都有）</span></span><br><span class="line"><span class="keyword">float</span> f = i.floatValue();<span class="comment">//手动拆箱</span></span><br><span class="line"><span class="comment">//输出结果：123.0</span></span><br><span class="line">System.out.println(f);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK1.5之后支持自动装箱、自动拆箱</span></span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">Integer a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line"></span><br><span class="line">Integer c = <span class="number">200</span>;</span><br><span class="line">Integer d = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//结果返回：false (==不会触发自动拆箱)</span></span><br><span class="line">System.out.println(c == d);</span><br><span class="line"><span class="comment">//结果返回：true</span></span><br><span class="line">System.out.println(c.equals(d));</span><br></pre></td></tr></table></figure><h1 id="什么时候用包装类？"><a href="#什么时候用包装类？" class="headerlink" title="什么时候用包装类？"></a>什么时候用包装类？</h1><p>看基本的业务来定：这个字段允不允许null值，如果允许null值，则必然要用封装类，否则值类型就可以了，用到比如泛型和反射调用函数.，就需要用包装类！</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>理解：  </p><ol><li><p><code>Integer派别：Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的,它们的默认最大值是128，最小值-128,如果超过就会重新实例化对象，如果超过值用等于等于比较就为false，没超过就为true。</code></p></li><li><p><code>Double派别：Double、Float的valueOf方法的实现是类似的。每次都返回不同的对象。</code>    </p></li><li><p><code>当一个基础数据类型与封装类进行等于等于、+、-、*、/运算时，会将封装类进行拆箱，对基础数据类型进行运算</code></p></li><li><p><code>equals比较是是本身</code></p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">200</span>;</span><br><span class="line">System.out.println(i==i1);  <span class="comment">//true</span></span><br><span class="line">System.out.println(i.equals(i1));  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">重点：</span><br><span class="line"><span class="number">1.</span> 基本数据类型和包装类比较</span><br><span class="line">    <span class="number">1.1</span> 使用 == ，Java会自动把包装类拆箱，进行值比较，</span><br><span class="line">    <span class="number">1.2</span> 使用equals进行比较也会自动拆箱，然后比较值</span><br><span class="line"><span class="number">2.</span> 包装类型和包装类型比较</span><br><span class="line">    <span class="number">2.1</span> 使用 == 比较，这里如果包装类的值没有超出于取值范围 并且值是一样为<span class="keyword">true</span>，如果超出取值范围就是<span class="keyword">false</span>（这时候与值无关）；</span><br><span class="line">    <span class="number">2.2</span> 使用equals比较,会自动拆箱,然后比较值。值相同为<span class="keyword">true</span>，不同为<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">Integer i5 = <span class="number">100</span>;</span><br><span class="line">Integer i6 = <span class="number">100</span>;</span><br><span class="line">Long i7 = <span class="number">100L</span>;</span><br><span class="line"><span class="keyword">long</span> i8 = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//编译报错 不同类型的包装类不能使用==比较</span></span><br><span class="line"><span class="comment">//System.out.println(i7==i6); </span></span><br><span class="line"><span class="comment">//不同类型使用equals进行比较 返回false</span></span><br><span class="line">System.out.println(i6.equals(i8)); </span><br><span class="line"><span class="comment">//不同的包装类和基本数据类型使用==比较，只要不超过取值范围为true</span></span><br><span class="line">System.out.println(i6==i8); </span><br></pre></td></tr></table></figure></li></ol><h2 id="取值范围"><a href="#取值范围" class="headerlink" title="取值范围"></a>取值范围</h2><table><thead><tr><th>类型</th><th>相同对象范围</th><th>不同对象范围</th></tr></thead><tbody><tr><td>Integer</td><td>-128,127</td><td>i &gt; 127,i &lt; -128</td></tr><tr><td>Short</td><td>-128,127</td><td>i &gt; 127,i &lt; -128</td></tr><tr><td>Character</td><td>0,127</td><td>i &gt; 128</td></tr><tr><td>Long</td><td>-128,127</td><td>i &gt; 127,i &lt; -128</td></tr></tbody></table><h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    Integer i1 </span>= <span class="number">100</span>;</span><br><span class="line">    Integer i2 = <span class="number">100</span>;</span><br><span class="line">    Integer i3 = <span class="number">200</span>;</span><br><span class="line">    Integer i4 = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">//从源码上来看Integer默认的最大值是127，最小值为-128都是final修饰的不可变，所以这里的i1==i2是true</span></span><br><span class="line">    System.out.println(i1==i2);  <span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//如果Integer的值最小超过-128或者最大值超过128，它就会重新创建对象，而i3和i4存的引用就是堆里面的引用所以这里返回false</span></span><br><span class="line">    System.out.println(i3==i4);  <span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面为源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Double"><a href="#Double" class="headerlink" title="Double"></a>Double</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Double i1 = <span class="number">100.0</span>;</span><br><span class="line">    Double i2 = <span class="number">100.0</span>;</span><br><span class="line">    Double i3 = <span class="number">200.0</span>;</span><br><span class="line">    Double i4 = <span class="number">200.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Double每次都会去new对象所以这里返回都是false</span></span><br><span class="line">    System.out.println(i1==i2); <span class="comment">//false</span></span><br><span class="line">    System.out.println(i3==i4); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面为源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">    Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//源码可见true和false是static final的</span></span><br><span class="line">    System.out.println(i1==i2);<span class="comment">//true</span></span><br><span class="line">    System.out.println(i3==i4);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面为源码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment"> * value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment"> * value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Integer num1 = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">//这里== 进行了自动拆箱 所以为true        </span></span><br><span class="line">    System.out.println(num1 == num2); <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//我们知道equal比较的是内容本身，并且我们也可以看到equal的参数是一个Object对象，我们传入的是一个int类型，所以首先会进行装箱，然后比较，之所以返回true，是由于它比较的是对象里面的value值。</span></span><br><span class="line">    System.out.println(num1.equals(num2));  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面为源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">包装类</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>类型与类型之间的关系</title>
    <link href="https://blog.myiszhb.cn/2020/12/14/7acf6980.html"/>
    <id>https://blog.myiszhb.cn/2020/12/14/7acf6980.html</id>
    <published>2020-12-14T12:24:21.000Z</published>
    <updated>2020-12-14T12:33:28.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="is-a"><a href="#is-a" class="headerlink" title="is a"></a>is a</h1><p>cat is a Animal  （猫是一只动物）<br>凡是能够满足is a的表示“继承关系”<br>A extends B  </p><h1 id="has-a"><a href="#has-a" class="headerlink" title="has a"></a>has a</h1><p>I has a Pen （我有一支笔）<br>凡是能够满足has a 关系的表示“关联关系”<br>关联关系通过以“属性”的形式存在。<br>A{<br>    B b;<br>}</p><h1 id="like-a"><a href="#like-a" class="headerlink" title="like a"></a>like a</h1><p>Cooker like a FoodMenu（厨司像一个菜单一样）<br>凡是能够满足like a 关系的表示“实现关系”<br>实现关系通常是：类实现接口。<br>A implement B  </p>]]></content>
    
    
    <summary type="html">类型与类型之间的关系</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java访问控制权限</title>
    <link href="https://blog.myiszhb.cn/2020/12/14/df717f7d.html"/>
    <id>https://blog.myiszhb.cn/2020/12/14/df717f7d.html</id>
    <published>2020-12-14T12:24:21.000Z</published>
    <updated>2020-12-14T12:34:55.789Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>修饰符</th><th>类的内部</th><th>同一包</th><th>子类</th><th>任何地方</th></tr></thead><tbody><tr><td>private</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr><tr><td>default</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>protected</td><td>yes</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>public</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><p>访问控制权限修饰符可以修饰什么？</p><ul><li>属性（4个都能用）</li><li>方法（4个都能用）</li><li>类（public和默认能用，其他不行）</li><li>接口（public和默认能用，其他不行）</li></ul>]]></content>
    
    
    <summary type="html">Java访问控制权限</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder区别</title>
    <link href="https://blog.myiszhb.cn/2020/12/13/88b1c03b.html"/>
    <id>https://blog.myiszhb.cn/2020/12/13/88b1c03b.html</id>
    <published>2020-12-13T11:33:11.000Z</published>
    <updated>2020-12-13T11:36:25.868Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思考：</span><br><span class="line">我们在实际的开发中，如果需要进行字符串的频繁拼接，会有什么问题？  </span><br><span class="line">因为java中的字符串是不可变的，每一次拼接都会产生新字符串。</span><br><span class="line">这样会占用大量的方法区内存，造成内存空间浪费。</span><br><span class="line">例如：</span><br><span class="line">    String s &#x3D; &quot;abc&quot;;</span><br><span class="line">    s +&#x3D; &quot;hello&quot;;</span><br><span class="line">    就以上两行代码，就导致在方法区字符串常量池当中创建了3个对象：</span><br><span class="line">    “abc”  &quot;hello&quot; &quot;abchello&quot;</span><br><span class="line"></span><br><span class="line">所以在大量的字符串拼接中，我们可以采用JDK自带的：</span><br><span class="line">    java.long.StringBuffer</span><br><span class="line">    java.long.StringBuilder</span><br></pre></td></tr></table></figure><h1 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h1><ol><li>StringBuffer、StringBuilder底层实际上是一个byte[]数组，往StringBuffer、StringBuilder中放字符串，实际上是放在byte数组当中的</li><li>StringBuffer、StringBuilder的初始容量是16。</li><li>StringBuffer、StringBuilder调用append()方法进行追加，如果容量不够，会自动扩容。底层实现原理通过System.arraycopy()方法进行扩容处理。</li><li>String的底层也是byte[]数组只不过是final修饰过的，所以不能改变。</li><li>如何优化StringBuffer、StringBuilder的性能？<br> <code>在创建StringBuffer、StringBuilder的时候尽可能的给定一个合适的初始容量，最好减少底层数组的扩容次数。</code></li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>String、StringBuffer、StringBuilder的区别？<ul><li>  StringBuffer中所有方法都有：synchronized关键字修饰，表示线程安全，在多线程下是安全的，但是效率较低，长度可变。</li><li>  StringBuilder没有synchronized关键字修饰，表示不线程安全，在多线程下是不安全的,但是效率高，长度可变。</li><li>  String是不可变的，因为String的底层也是byte[]数组只不过是final修饰过的，所以不能改变。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">String、StringBuffer、StringBuilder区别</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String类</title>
    <link href="https://blog.myiszhb.cn/2020/12/12/5cf35ca9.html"/>
    <id>https://blog.myiszhb.cn/2020/12/12/5cf35ca9.html</id>
    <published>2020-12-12T13:17:01.000Z</published>
    <updated>2020-12-12T13:48:40.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String是上面"><a href="#String是上面" class="headerlink" title="String是上面"></a>String是上面</h1><ol><li>String表示字符串类型，属于引用数据类型，不属于基本数据类型。</li><li>Java中规定，双引号括起来的字符串，是不可变的，也就是说“abc”自出生到最终死亡，都是不能改变的。</li><li>在JDK当中双引号括起来的字符串，例如：“abc” 都是直接存储在方法区的字符串常量池当中的。</li></ol><p>内存分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//s1 和s2 一共创建了3个字符串对象，都在字符串常量池当做</span></span><br><span class="line">        String s1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;abcdef&quot;</span>+<span class="string">&quot;xy&quot;</span>;</span><br><span class="line">        <span class="comment">//凡是使用双引号括起来的都在字符串常量池中有一份.</span></span><br><span class="line">        <span class="comment">//new对象的时候一定在堆内存当中开辟空间</span></span><br><span class="line">        <span class="comment">//所以 栈当中s3存的是 推内存的地址 ，而堆内存当做存的是xy在字符串常量池中的地址</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;xy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200917140308302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTE0NzY2,size_16,color_FFFFFF,t_70" alt="image"></p><h1 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**(掌握)1. charAt(index) **/</span></span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">&quot;中国人&quot;</span>.charAt(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//输出国</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)2. int compareTo(String anotherString)</span></span><br><span class="line"><span class="comment">         * 按照字典顺序比较两个字符串</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="string">&quot;a&quot;</span>.compareTo(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="comment">//输出0 前后一致 举例：10 - 10 = 0</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">int</span> result2 = <span class="string">&quot;d&quot;</span>.compareTo(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        <span class="comment">//输出-1 前小后大 举例：10 - 11 = -1</span></span><br><span class="line">        System.out.println(result2);</span><br><span class="line">        <span class="keyword">int</span> result3 = <span class="string">&quot;e&quot;</span>.compareTo(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        <span class="comment">//输出0 前大后小  举例：11 - 10 = 1</span></span><br><span class="line">        System.out.println(result3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)3. boolean contains(CharSequence s)</span></span><br><span class="line"><span class="comment">         * 当且仅当此字符串包含指定的char值序列是，返回true</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//如果包含就为true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.contains(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        <span class="comment">//不包含为false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.contains(<span class="string">&quot;d&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)4. boolean endsWith(Sting suffix)</span></span><br><span class="line"><span class="comment">         * 判断当前字符串是否以某个字符串结尾。</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//返回false 结尾不是以.java结尾的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test.txt&quot;</span>.endsWith(<span class="string">&quot;.java&quot;</span>));</span><br><span class="line">        <span class="comment">//返回true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test.txt&quot;</span>.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)5. boolean startWith(Sting suffix)</span></span><br><span class="line"><span class="comment">         * 判断当前字符串是否以某个字符串开始</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//返回true 因为这个字符串就是以test开始的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test.txt&quot;</span>.endsWith(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        <span class="comment">//返回false 因为字符串不是以a开始的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test.txt&quot;</span>.endsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)6. boolean equals(Object anObject)</span></span><br><span class="line"><span class="comment">         * 比较两个字符串必须使用equals方法，不能使用“==”</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//返回true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.equals(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        <span class="comment">//返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.equals(<span class="string">&quot;abcd&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)7. boolean equalsIgnoreCase(String antherString)</span></span><br><span class="line"><span class="comment">         * 判断两个字符串是否相等，并且忽略大小写</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//返回true 因为忽略了大小写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.equalsIgnoreCase(<span class="string">&quot;ABc&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)8. byte[] getBytes()</span></span><br><span class="line"><span class="comment">         * 将字符串对象转换成字节数组</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="string">&quot;abcdef&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">//输出结果 97 98 99 100 101 102</span></span><br><span class="line">        <span class="comment">//把每个字符串都拆分 并且转换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;bytes.length ; i++) &#123;</span><br><span class="line">            System.out.print(bytes[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)9. int indexOf(String str)</span></span><br><span class="line"><span class="comment">         * 判断某个字符串在当前字符串第一次出现处的索引</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出下标1,因为b在这个字符串的下标1，第一次出现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abcbef&quot;</span>.indexOf(<span class="string">&quot;b&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)10. int lastIndexOf(String str)</span></span><br><span class="line"><span class="comment">         * 判断某个字符串在当前字符串最后一次次出现处的索引</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：3 ,因为b在当前字符串最后一次出现的索引是3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abcbef&quot;</span>.lastIndexOf(<span class="string">&quot;b&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)11. boolean isEmpty()</span></span><br><span class="line"><span class="comment">         * 判断某个字符串是否为空</span></span><br><span class="line"><span class="comment">         * 这里判断的是空字符串“”，而不是null，如果s=null的话 调用此方法会出现空指针异常</span></span><br><span class="line"><span class="comment">         * 这个方法底层调用的就是string的length方法。</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//返回true 因为是空字符串</span></span><br><span class="line">        System.out.println(s.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)12. int length()</span></span><br><span class="line"><span class="comment">         * 判断某个字符串的长度</span></span><br><span class="line"><span class="comment">         * 面试题：判断数组长度和判断字符串长度不一样</span></span><br><span class="line"><span class="comment">         * 判断数组长度用的是length属性，判断字符串长度是length()方法</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)13. String replace(CharSequence target,CharSequence replacement)</span></span><br><span class="line"><span class="comment">         * 字符串替换</span></span><br><span class="line"><span class="comment">         * String的父接口就是：CharSequence</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：https://myiszhb.cn ,把字符串中的http替换成https</span></span><br><span class="line">        System.out.println(<span class="string">&quot;http://myiszhb.cn&quot;</span>.replace(<span class="string">&quot;http&quot;</span>,<span class="string">&quot;https&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)14. String[] split(String regex)</span></span><br><span class="line"><span class="comment">         *  字符串切割</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        String[] vs = <span class="string">&quot;avcdefg&quot;</span>.split(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        <span class="comment">//输出结果av defg ，因为是按照c进行分割的</span></span><br><span class="line">        <span class="keyword">for</span> (String v : vs) &#123;</span><br><span class="line">            System.out.print(v+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)15. String substring(int beginIndex)</span></span><br><span class="line"><span class="comment">         *  截取字符串</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：ttps://myiszhb.cn 因为是从索引1还是截取的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;https://myiszhb.cn&quot;</span>.substring(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)16. String substring(int beginIndex，int endIndex)</span></span><br><span class="line"><span class="comment">         *  截取字符串 substring的重载方法</span></span><br><span class="line"><span class="comment">         *  参数： beginIndex - 起始索引（包括）</span></span><br><span class="line"><span class="comment">         *         endIndex  -  结束索引（不包括）</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：tt 因为是从索引1开始截取，到索引3结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;https://myiszhb.cn&quot;</span>.substring(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)17. char[] toCharArray()</span></span><br><span class="line"><span class="comment">         *  将字符串转换成char数组</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="string">&quot;我是四川人&quot;</span>.toCharArray();</span><br><span class="line">        <span class="comment">//输出结果： 我 是 四 川 人</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">            System.out.print(aChar+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)18. String toLowerCase()</span></span><br><span class="line"><span class="comment">         *  将字符串转换成小写</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：abc</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABC&quot;</span>.toLowerCase());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)19. String toUpperCase()</span></span><br><span class="line"><span class="comment">         *  将字符串转换成大写</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：ABC</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.toUpperCase());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)20. String trim()</span></span><br><span class="line"><span class="comment">         *  忽略字符串前面和尾部的空白</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果：asf f 前面后面的空白就去除了 中间的不会去除</span></span><br><span class="line">        System.out.println(<span class="string">&quot; asf f &quot;</span>.trim());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**(掌握)21. valueOf()</span></span><br><span class="line"><span class="comment">         * String中只有一个方法是静态的，不需要new对象 那就是valueOf()方法</span></span><br><span class="line"><span class="comment">         *  将非字符串（不是字符串的）转换成字符串</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        <span class="comment">//输出结果:1 ,而这里输出出来的1已经变成字符串的1了，而不是int类型的1</span></span><br><span class="line">        System.out.println(String.valueOf(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">String</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多种数据类型混合运算</title>
    <link href="https://blog.myiszhb.cn/2020/12/11/d57302f2.html"/>
    <id>https://blog.myiszhb.cn/2020/12/11/d57302f2.html</id>
    <published>2020-12-11T12:18:34.000Z</published>
    <updated>2020-12-11T12:21:58.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="byte、short、char混合运算"><a href="#byte、short、char混合运算" class="headerlink" title="byte、short、char混合运算"></a>byte、short、char混合运算</h1><p>结论:byte、char、short 做混合运算的时候，各自先转换成int再做运算。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//这里可以输出98，因为ascll表a的值是97</span></span><br><span class="line">        System.out.println(c1+b);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//short s = c1+b;这里编译出错，编译器不知道这个结果是什么。</span></span><br><span class="line">        </span><br><span class="line">       <span class="comment">// short d = (short)c1+b;这里也是编译出错，因为它先把c1转换成了short然后在和b相加，最终结果还是不知道。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">short</span> f = (<span class="keyword">short</span>)(c1+b);<span class="comment">//这里可以正常编译，因为它是把c1+b进行相加后 在强转成short的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//short d = s;这里编译出错，因为s的值要运行时才知道，而这里还没运行 编译器不知道，直接出错。</span></span><br><span class="line">        <span class="keyword">short</span> d = <span class="number">1</span>;<span class="comment">//这里正常，因为编译器知道这个值。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多种数据类型混合运算-整数型"><a href="#多种数据类型混合运算-整数型" class="headerlink" title="多种数据类型混合运算(整数型)"></a>多种数据类型混合运算(整数型)</h1><p>结论：多种数据类型做混合运算的时候，最终结果是最大容量的类型<br>注意：byte、char、short 除外，会各自先转换成int</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a = <span class="number">10L</span>;</span><br><span class="line">        <span class="keyword">char</span> b = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line">        <span class="comment">//求和</span></span><br><span class="line">        System.out.println(a+b+s+i);</span><br><span class="line">        <span class="comment">//int d = a+b+s+i;//这里算出来是long类型，编译错误 不兼容类型：从long转换成int</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//以下程序执行结果是？</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">10</span>/<span class="number">3</span>;<span class="comment">//结果为：3，因为int/int类型结果还是int类型，最终结果取整。</span></span><br><span class="line">        <span class="keyword">int</span> temp2 = <span class="number">1</span>/<span class="number">2</span>;<span class="comment">//结果为：0，因为int/int类型结果还是int类型，最终结果取整。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="浮点型混合运算-浮点型"><a href="#浮点型混合运算-浮点型" class="headerlink" title="浮点型混合运算(浮点型)"></a>浮点型混合运算(浮点型)</h1><ul><li>浮点型包括<ul><li>  float 4个字节 单精度</li><li>  double 8个字节 双精度</li></ul></li></ul><p>例如：<br>10.0/3 如果采用float来存储的话结果可能是：3.3333<br>10.0/3 如果采用double来存储的话结果可能是：3.33333333<br><code>注意：double不能用于财务方面的运算，会丢失精度，最好使用BigDecimal，BigDecimal属于引用类型</code></p><p>float和double存储数据的时候都是存储的近似值，因为在运算的时候有时候会出现无限循环的数据。</p><p><code>注意：任意一个浮点型数据的类型容量都比整数数据类型容量大。</code>  </p><p><code>注意：java中规定任何一个浮点型都会默认被当做double来处理，如果想让这个浮点数字面量被当做flota类型来处理，那么要在字面量后面加上F/f</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">3.14</span>;<span class="comment">//编译出错，不兼容的类型，从double转成float</span></span><br><span class="line"><span class="comment">//第一种转换方法：</span></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">3.14F</span>;(或者<span class="number">3.14f</span>)</span><br><span class="line"></span><br><span class="line">/第二种 强制转换，可能会丢失精度，谨慎使用</span><br><span class="line"><span class="keyword">float</span> c = (<span class="keyword">float</span>)<span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析这个程序，可以编译吗？</span></span><br><span class="line"><span class="comment">//错误：不兼容的类型，从double转成int</span></span><br><span class="line"><span class="comment">//原理：先将5转换成double类型，然后在做运算，结果是double，大容量无法直接赋值给小容量，需要强转！</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10.0</span>/<span class="number">5</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多种数据类型混合运算</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>二进制的原码、反码、补码</title>
    <link href="https://blog.myiszhb.cn/2020/12/10/c3d59d66.html"/>
    <id>https://blog.myiszhb.cn/2020/12/10/c3d59d66.html</id>
    <published>2020-12-10T12:06:58.000Z</published>
    <updated>2020-12-11T12:19:52.074Z</updated>
    
    <content type="html"><![CDATA[<ol><li>计算机在任何情况下都只能识别二进制</li><li>计算机在底层存储数据的时候，一律存储的是”二进制的补码形式”，计算机采用补码形式存储数据的原因是：补码形式效率最高</li><li>什么是补码？<br>二进制有：原码 反码 补码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于一个正数来说：二进制原码、反码、补码是同一个，完全相同</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">对应的二进制原码：<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span></span><br><span class="line">对应的二进制反码：<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span></span><br><span class="line">对应的二进制补码：<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对一个负数来说：二进制原码、反码、补码是什么关系呢？</span></span><br><span class="line"><span class="keyword">byte</span> i = -<span class="number">1</span>;</span><br><span class="line">对应的二进制原码： <span class="number">10000001</span></span><br><span class="line">对应的二进制反码(符号位不变，其他位取反)： <span class="number">11111110</span></span><br><span class="line">对应的二进制补码(反码+<span class="number">1</span>)： <span class="number">11111111</span></span><br></pre></td></tr></table></figure>问题：byte b = (byte)150；输出多少？？<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)<span class="number">150</span>;<span class="comment">//这里输出-106</span></span><br><span class="line"></span><br><span class="line">    <span class="number">128</span> <span class="number">64</span> <span class="number">32</span> <span class="number">16</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line">    <span class="number">1</span>   <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> （这里是<span class="number">128</span>，<span class="number">150</span>-<span class="number">128</span>=<span class="number">22</span>）</span><br><span class="line">    <span class="number">1</span>   <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> （<span class="number">16</span>+<span class="number">4</span>+<span class="number">2</span>=<span class="number">22</span>）</span><br><span class="line">    </span><br><span class="line"><span class="number">11001</span> <span class="number">0110</span> (最终结果这是一个二进制补码形式)</span><br><span class="line">二进制原码为：<span class="number">1110</span> <span class="number">1010</span></span><br><span class="line">二进制反码为：<span class="number">1001</span> <span class="number">0101</span></span><br><span class="line">二进制补码为：<span class="number">1001</span> <span class="number">0110</span></span><br><span class="line">其中符号位是<span class="number">1</span>所以是负数</span><br><span class="line"><span class="number">0</span>+<span class="number">2</span>+<span class="number">0</span>+<span class="number">8</span>+<span class="number">0</span>+<span class="number">32</span>+<span class="number">64</span>=-<span class="number">106</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;计算机在任何情况下都只能识别二进制&lt;/li&gt;
&lt;li&gt;计算机在底层存储数据的时候，一律存储的是”二进制的补码形式”，计算机采用补码形式存储数据的原因是：补码形式效率最高&lt;/li&gt;
&lt;li&gt;什么是补码？&lt;br&gt;二进制有：原码 反码 补码&lt;figure class=</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="https://blog.myiszhb.cn/2020/12/09/23a3bd72.html"/>
    <id>https://blog.myiszhb.cn/2020/12/09/23a3bd72.html</id>
    <published>2020-12-09T11:41:47.000Z</published>
    <updated>2020-12-11T12:20:19.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><ol><li>软件程序运行过程中，非常可能遇到问题，这就是异常。</li><li>异常指程序运行中出现的不期而遇的各种状况，如：文件找不到，网络连接失败等。</li><li>异常发生在程序运行期间，它影响了正常的程序执行流程。</li><li>一次在Java中以类的形式存在，每一个异常类都可以创建异常对象</li></ol><h1 id="异常分为三种类型"><a href="#异常分为三种类型" class="headerlink" title="异常分为三种类型"></a>异常分为三种类型</h1><ol><li>检查性异常<br>最具代表的检查性异常时用户错误或问题引发的异常，这是程序员无法预见的，例如打开了一个不存在的文件时，一个异常就发送了，这些异常在编译时不能被简单地忽略。</li><li>运行时异常<br>运行时异常时可以被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li>错误<br>错误不是异常，而实脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ol><h1 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h1><ol><li>Java把异常当作对象来处理，并定义一个基类java.long.Throwable做为所有异常的超类。</li><li>在Java API中已定义了很多异常类，这些异常类分为两大类<ul><li>错误 Error</li><li>异常 Exception</li></ul></li></ol><h1 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h1><p>处理异常的五个关键字</p><ul><li>try  （try…catch，可以只有try）</li><li>catch   （catch和try连用，没有try是不行的）</li><li>finally （不管什么情况，finally块中的代码都会执行,除非碰到System.exit(0)退出jvm虚拟机）</li><li>throw() （throw()主动抛出异常）</li><li>throws （throws向上级抛出异常，如果抛到jvm虚拟机，程序将直接停止）</li></ul><p>try…cathc语句中出现finally块，不管程序是否出现异常或者return，finally块中的代码都会执行，除非碰到System.exit(0)退出jvm虚拟机。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch&quot;</span>)</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finaly&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><ol><li>创建自定义异常类。</li><li>在方法中通过throw关键字抛出异常对象。</li><li>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处理throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义异常extends Exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyException&#123;&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;自定义了一个异常&#125;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常问题"><a href="#异常问题" class="headerlink" title="异常问题"></a>异常问题</h1><ol><li>个人理解如果方法内，return 返回的对象可以不用赋值的话，在finally里面就可以更改，如果必须赋初始化值，finally里面就无法改变，列入：<br> String s = null; 不可改变<br> List list = null;不可改变<br> List list = new ArryList();可改变 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ages)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = m();</span><br><span class="line">        <span class="comment">//输出100</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Java语法规则（有一些规则是不能破坏的，一旦这么说，就必须这么做！）</span></span><br><span class="line">    <span class="comment">/**Java中有一条这样的规则：</span></span><br><span class="line"><span class="comment">      * 1.方法体中的代码必须遵循自上而下顺序依次逐行执行！</span></span><br><span class="line"><span class="comment">      * 2.return语句一旦执行，整个方法必须结束！</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//这行代码出现在int i = 100 的下面，所以最终结果必须是返回100</span></span><br><span class="line">            <span class="comment">//return语句还必须保证是最后执行的，一旦执行，整个方法结束。</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. final、finally、finalize的区别？</span><br><span class="line">    1. final是一个关键字，表示最终的，不可变的</span><br><span class="line">    2. finally也是一个关键字，和try联合使用，使用在异常机制中，finally语句块中的代码是一定会执行的。</span><br><span class="line">    3. finalize()是Object类中的一个方法。作为方法名称出现，所以finalize是一个标识符。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">异常</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="https://blog.myiszhb.cn/2020/12/09/9bc01b38.html"/>
    <id>https://blog.myiszhb.cn/2020/12/09/9bc01b38.html</id>
    <published>2020-12-09T11:41:33.000Z</published>
    <updated>2020-12-11T12:20:05.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是内部类"><a href="#什么是内部类" class="headerlink" title="什么是内部类"></a>什么是内部类</h1><p>内部类就是在一个类的内部在定义一个类，比如，A类中定义一个B类，那么B类相对于A类来说就成为内部类，而A类相对B类来说就是外部类。</p><h1 id="内部类分为4种"><a href="#内部类分为4种" class="headerlink" title="内部类分为4种"></a>内部类分为4种</h1><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外部类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是内部类的方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内部类可获取外部的私有属性</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getID</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//通过外部类实例化内部类</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.in();</span><br><span class="line">        inner.getID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外部类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是内部类的方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//静态内部类是无法拿到外部类的私有属性的，因为静态的会先被加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Outer.Inner.in();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="comment">//局部内部类</span></span><br><span class="line">    <span class="comment">//在方法里定义的类 就是局部内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//没有名字初始化类，不用将实例保存到变量中，就是匿名内部类</span></span><br><span class="line">       <span class="keyword">new</span> Outer().method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">内部类</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>接口</title>
    <link href="https://blog.myiszhb.cn/2020/12/08/5951da65.html"/>
    <id>https://blog.myiszhb.cn/2020/12/08/5951da65.html</id>
    <published>2020-12-08T11:05:06.000Z</published>
    <updated>2020-12-14T12:32:59.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h1><ul><li>普通类：只有具体实现</li><li>抽象类：具体实现和规范(抽象方法)都有！</li><li>接口：只有规范！</li></ul><ol><li>接口就是规范，定义的是一组规则，体现了现实世界中”如果你是…则必须能…”的思想。如果你是天使则必须能飞。</li><li><code>接口的本质是契约</code>，就像我们人类的法律一样。制定好后大家都遵守。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义接口的关键字 interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接口里面的方法都是抽象的 public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类 可以实现接口 通过关键字 implements</span></span><br><span class="line"><span class="comment">//实现接口就不必重写接口里面的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="==总结=="></a>==<strong>总结</strong>==</h1><ol><li>接口就是一种约束(<code>接口里面只能出现抽象方法和常量</code>)</li><li>接口定义了一些方法，可以让不同的人实现</li><li>接口里面定义的方法都是 public abstract (<code>可以直接忽略不写</code>)</li><li>接口里面定义的常量都是 public static final (<code>可以直接忽略不写</code>)</li><li>接口不能被实例化，接口中没有构造方法。</li><li>implements可以实现多个接口</li><li>类实现了接口就必须重写接口里面的方法。</li><li>接口中的方法都是抽象方法，所以接口里的方法不能有方法体。</li><li>接口可以多继承接口。</li><li>实现接口的类，方法的访问权限不能比接口底。</li><li>接口的使用离不开多态度机制（接口+多态才能达到解耦合）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里是多态的一种表现</span></span><br><span class="line">        <span class="comment">//抽象类是不能够被实例化的</span></span><br><span class="line">        MyMath my = <span class="keyword">new</span> MyMathImpl();</span><br><span class="line">        my.sum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="comment">//  public static final double PI=3.1415936; 效果一样，可以省略不写 public static final    </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//  public abstract int sum(int a,int b); 效果与上面的一样 这里public abstract可以省略    </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非抽象类实现了抽象类必须重写方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMathImpl</span> <span class="keyword">implements</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*  这里的访问修饰符不能比抽象类方法的访问修饰符权限低 只能比它高  </span></span><br><span class="line"><span class="comment">    private int sum(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h1><ol><li>抽象类是半抽象的，接口是完全抽象的。</li><li>抽象类中有构造方法，接口中没有构造方法。</li><li>接口和接口之间支持多继承，类和类之间只能单集成。</li><li>一个类可以同时实现多个接口，一个抽象类只能继承一个类（单继承）。</li><li>接口中只允许出现常量和抽象方法。</li></ol>]]></content>
    
    
    <summary type="html">接口</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>类与对象的关系</title>
    <link href="https://blog.myiszhb.cn/2020/12/08/d1212574.html"/>
    <id>https://blog.myiszhb.cn/2020/12/08/d1212574.html</id>
    <published>2020-12-08T11:03:26.000Z</published>
    <updated>2020-12-11T12:19:57.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a>什么是类？</h1><p><code>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表每一个具体的事物</code></p><h1 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h1><p><code>对象是抽象概念的具体实例</code></p><h2 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h2><ul><li><code>使用new关键字创建对象</code></li><li>使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认初始化以及对类中构造器的调用。</li><li>类中的构造器也被称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点  <ol><li>必须和类的名称相同</li><li>必须没有返回类型，也不能写void</li></ol></li></ul><p>重点：<code>类里面定义了有参构造器就必须定义一个无参构造器</code></p>]]></content>
    
    
    <summary type="html">类与对象的关系</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>抽象类</title>
    <link href="https://blog.myiszhb.cn/2020/12/07/3dbae4e.html"/>
    <id>https://blog.myiszhb.cn/2020/12/07/3dbae4e.html</id>
    <published>2020-12-07T11:48:07.000Z</published>
    <updated>2020-12-11T12:19:46.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是抽象类"><a href="#什么是抽象类" class="headerlink" title="什么是抽象类"></a>什么是抽象类</h1><ol><li>abstract修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法，如果修饰类那么该类就是抽象。</li><li>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。</li><li>抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。</li><li>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。</li><li>子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。</li><li>抽象类里面可以写普通方法。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//abstract 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//约束·有人帮忙实现</span></span><br><span class="line">    <span class="comment">//abstract 抽象方法，只有 方法名称 没有方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类的方法必须要有继承它的子类去实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h1><ol><li>抽象类不能new出来，只能靠子类去实现它，是一种约束!</li><li>抽象类中可以写普通的方法。</li><li>抽象方法必须在抽象类中。</li><li>抽象类也是属于引用数据类型。</li><li>抽象类的子类也可以是抽象类。</li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>抽象类里面有构造方法吗？<br>有</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">s</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">抽象类</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>static关键字</title>
    <link href="https://blog.myiszhb.cn/2020/12/06/ce244871.html"/>
    <id>https://blog.myiszhb.cn/2020/12/06/ce244871.html</id>
    <published>2020-12-06T12:12:53.000Z</published>
    <updated>2020-12-11T12:20:34.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ages)</span></span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">匿名代码块</span><br><span class="line">构造方法</span><br><span class="line">===============</span><br><span class="line">匿名代码块</span><br><span class="line">构造方法</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>第一次执行先执行静态代码块 在执行匿名代码块 最后执行构造方法</li><li>静态方法只执行一次</li></ol><h1 id="静态导入包"><a href="#静态导入包" class="headerlink" title="静态导入包"></a>静态导入包</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态导入包</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.<span class="keyword">long</span>.Math.random;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.<span class="keyword">long</span>.Math.PI;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ages)</span></span>&#123;</span><br><span class="line">        System.out.println(random());</span><br><span class="line">        System.out.println(PI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态属性及方法"><a href="#静态属性及方法" class="headerlink" title="静态属性及方法"></a>静态属性及方法</h1><p>静态的属性和方法可以直接通过类名调用</p>]]></content>
    
    
    <summary type="html">static关键字</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的3大特征</title>
    <link href="https://blog.myiszhb.cn/2020/12/05/7867351e.html"/>
    <id>https://blog.myiszhb.cn/2020/12/05/7867351e.html</id>
    <published>2020-12-05T09:01:36.000Z</published>
    <updated>2020-12-11T12:20:00.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ol><li><p>该露的露，该藏的藏</p><p> 我们程序设计追求<code>高内聚，低耦合</code>。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅量暴露少量的方法给我外部使用</p></li><li><p>封装（数据的隐藏）</p><p> 通常，应静止直接访问一个对象中的实际表示，而应通过操作接口来访问，这称为信息隐藏。</p></li></ol><p><code>记住这句话就够了：属性私有，get/set</code></p><p><code>封装的核心private私有化</code></p><h2 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h2><ol><li>提高程序的安全性，保护数据</li><li>隐藏代码的实现细节</li><li>统一接口</li><li>系统可维护性增加</li></ol><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol><li>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</li><li><code>extends</code>的意思是”扩展”。子类是分类的扩展。</li><li><code>Java中类只有单继承，没有多继承！</code></li><li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</li><li>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示。</li><li>子类和父类之间，从意义上讲应该具有”is a”的关系。  </li></ol><p>重点：</p><ul><li>object类  </li><li>super  </li><li>方法重写 </li></ul><h2 id="继承注意"><a href="#继承注意" class="headerlink" title="继承注意"></a>继承注意</h2><ol><li><p>super注意点：</p><ul><li>super调用父类的构造方法，必须在构造方法的第一个</li><li>super必须只能出现在子类的构造方法中！</li><li>super和this不能同时调用构造方法！</li></ul></li><li><p>this</p><ol><li>代表的不同对象：<ul><li>this:本身调用者这个对象</li><li>super：代表父类对象的引用</li></ul></li><li>前提<ul><li>this：没有继承也可以使用</li><li>super：只能在继承条件才可以使用</li></ul></li><li>构造方法<ul><li>this() 本类的构造</li><li>super() 父类的构造</li></ul></li></ol></li></ol><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><ol><li>重写都是方法的重写，和属性无关</li><li>构造方法不能被继承，所以构造方法也不能被重写。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123; </span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1==&gt;A==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="comment">//Override 重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2==&gt;B==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//方法的调用只和左边定义的数据类型有关</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//父类的引用指向了子类</span></span><br><span class="line">        B b = <span class="keyword">new</span> A();<span class="comment">//非静态下子类重写了父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态方法输出结果</span></span><br><span class="line">B==&gt;test()</span><br><span class="line">A==&gt;test()</span><br><span class="line"></span><br><span class="line"><span class="comment">//非静态方法输出结果</span></span><br><span class="line">test2==&gt;B==&gt;test()</span><br><span class="line">test2==&gt;B==&gt;test()</span><br></pre></td></tr></table></figure><h2 id="重写注意"><a href="#重写注意" class="headerlink" title="重写注意"></a>重写注意</h2><ol><li>需要有继承关系，子类重写父类的方法！</li><li>方法名必须相同</li><li>参数列表必须相同</li><li>修饰符：范围可以扩大但不能缩小，public&gt;Protected&gt;Default&gt;private</li><li>抛出的异常：<ul><li>编译时异常：范围可以缩小，但不能扩大。ClassNotFoundException–&gt;Exception(大)</li><li>运行时异常：可以直接抛出！</li></ul></li><li>重写，子类的方法和父类必须要一致，方法体不同！</li><li>只要子类重写了父类的方法一定走的是子类的方法。  </li><li>方法覆盖只是针对方法，和属性无关。</li><li>私有方法无法被覆盖</li><li>方法重写只针对实例方法。  </li><li>为什么需要重写：<ul><li>父类的功能，子类不一定需要，或者不一定满足！</li></ul></li></ol><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ol><li>动态编译：类型：可扩展性</li><li>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</li><li>一个对象的实现类型是确定的，但可以只想对象的引用的类型很多。</li><li>多态存在的条件<ul><li>有继承关系</li><li>子类重写父类方法</li><li>父类引用指向子类对象</li></ul></li></ol><h2 id="多态注意"><a href="#多态注意" class="headerlink" title="多态注意"></a>多态注意</h2><ol><li>多态是方法的多态，属性没有多态性</li><li>父类和子类，有联系 类型转换异常！ ClassCastException!</li><li>存在条件：继承关系，方法需要重写，父类引用指向子类对象！ Father f1 = new Son();<ul><li>但有些方法是不能被重写的！<ul><li>static 方法，属于类，它不属于实例；</li><li>final 常量；</li><li>private 方法；</li></ul></li></ul></li></ol><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p>严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;go&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//Object &gt; String</span></span><br><span class="line">        <span class="comment">//Object &gt; Person &gt; Teacher</span></span><br><span class="line">        <span class="comment">//Object &gt; Person &gt; Student</span></span><br><span class="line">        Object object = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Student);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Teacher);<span class="comment">//false</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> String);<span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>总结</code><br>X instanceof Y 如果没有父子关系编译直接报错。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//类型之间的转换</span></span><br><span class="line">        <span class="comment">//高                低</span></span><br><span class="line">        Person obj = <span class="keyword">new</span> Student();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//obj，我们就可以使用Student类型的方法</span></span><br><span class="line">        <span class="comment">//高转低 需要强制转换</span></span><br><span class="line">        <span class="comment">//子类转父类(低转高) 可能会丢失自己本身的一些方法</span></span><br><span class="line">        Student student=(Student)obj;</span><br><span class="line">        student.go();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态总结"><a href="#多态总结" class="headerlink" title="多态总结"></a>多态总结</h2><ol><li>父类引用指向子类的对象。</li><li>把子类转换成父类，向上转型。</li><li>把父类转成子类，向下转型，强制转换。</li><li>方便方法的调用，减少重复的代码。</li></ol>]]></content>
    
    
    <summary type="html">面向对象的3大特征</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>什么是面向过程、面向对象</title>
    <link href="https://blog.myiszhb.cn/2020/12/04/c5d97b3b.html"/>
    <id>https://blog.myiszhb.cn/2020/12/04/c5d97b3b.html</id>
    <published>2020-12-04T12:13:01.000Z</published>
    <updated>2020-12-11T12:20:11.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向过程思想"><a href="#面向过程思想" class="headerlink" title="面向过程思想"></a>面向过程思想</h1><ol><li><p>步骤清晰简单，第一步做什么，第二步做什么。</p></li><li><p>面对过程适合处理一些较为简单的问题。</p></li><li><p>面向过程都是有因果关系的，比如，因为A所以才有B….</p></li></ol><p><code>面向过程的缺点：高耦合,可扩展性差，一步错步步错。</code></p><p><code>面向过程的优点：对于小型项目，效率较高，不用抽取对象，可直接编码。</code></p><h1 id="什么是OOA、OOD、OOP"><a href="#什么是OOA、OOD、OOP" class="headerlink" title="什么是OOA、OOD、OOP"></a>什么是OOA、OOD、OOP</h1><ol><li>OOA 面向对象分析</li><li>OOD 面向对象设计</li><li>OOP 面向对象编码</li></ol><h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><ol><li><p>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后才对某个分类下的细节进行面向过程的思考。</p></li><li><p>面向对象适合处理复杂的问题，适合处理需要多人协作的问题!</p></li><li><p><code>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</code></p></li></ol><h1 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h1><ol><li><p>面向对象编程的本质就是：<code>以类的方式组织代码，以对象的组织（封装）数据</code></p></li><li><p>抽象（抽象就是抽取事物的相同点）</p></li><li><p>封装（封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制）</p><ul><li><p>良好的封装能够减少耦合。</p></li><li><p>类内部的结构可以自由修改。</p></li><li><p>可以对成员变量进行更精确的控制。</p></li><li><p>隐藏信息，实现细节。 </p></li></ul></li><li><p>继承</p></li><li><p>多态（一种事物有多种形态）</p></li><li><p>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</p></li><li><p>从代码运行角度考虑是先有类后有对象。类是对象的模板。</p></li></ol>]]></content>
    
    
    <summary type="html">什么是面向过程、面向对象</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组</title>
    <link href="https://blog.myiszhb.cn/2020/12/03/a6455d41.html"/>
    <id>https://blog.myiszhb.cn/2020/12/03/a6455d41.html</id>
    <published>2020-12-03T12:29:50.000Z</published>
    <updated>2020-12-11T12:20:17.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是稀疏数组？"><a href="#什么是稀疏数组？" class="headerlink" title="什么是稀疏数组？"></a>什么是稀疏数组？</h1><ol><li>当一个数组中大步幅元素为0，或者为同一个值的数组是，可以使用稀疏数组来保持该数组。</li><li>稀疏数组的处理方式<ul><li>记录数组一共有几行几列，有多少个不同值</li><li>把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">10</span>];</span><br><span class="line">array[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">array[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">System.err.println(<span class="string">&quot;输出棋盘:&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">System.out.print(array[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//获取有效数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(array[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">count = ++count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[][] num = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//获取总共有多少行</span></span><br><span class="line">num[<span class="number">0</span>][<span class="number">0</span>] = array.length;</span><br><span class="line"><span class="comment">//获取总共有多少列</span></span><br><span class="line">num[<span class="number">0</span>][<span class="number">1</span>] = array[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">//赋值有效数据</span></span><br><span class="line">num[<span class="number">0</span>][<span class="number">2</span>] = count;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//获取稀疏数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(array[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">num[number][<span class="number">0</span>] = i;</span><br><span class="line">num[number][<span class="number">1</span>] = j;</span><br><span class="line">num[number][<span class="number">2</span>] = array[i][j];</span><br><span class="line">number++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.err.println(<span class="string">&quot;转换后的结果:&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[i].length; j++) &#123;</span><br><span class="line">System.out.print(num[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//取出稀疏数组的行列</span></span><br><span class="line"><span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[num[<span class="number">0</span>][<span class="number">0</span>]][num[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">System.err.println(<span class="string">&quot;还原稀疏数组:&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//渲染稀疏数组有效值从第一行开始渲染</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">nums[num[i][<span class="number">0</span>]][num[i][<span class="number">1</span>]] = num[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i].length; j++) &#123;</span><br><span class="line">System.out.print(nums[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出棋盘:</span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">1</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">5</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line">转换后的结果:</span><br><span class="line">列  行  值</span><br><span class="line"><span class="number">11</span><span class="number">10</span><span class="number">2</span>   <span class="comment">//第一行表示一共有11行10列有效值为2个</span></span><br><span class="line"><span class="number">1</span><span class="number">2</span><span class="number">1</span>   <span class="comment">//第二行表示第一个值在第1行第2列值是1</span></span><br><span class="line"><span class="number">3</span><span class="number">4</span><span class="number">5</span>   <span class="comment">//第三行表示第二个值在第3行第4列值是5，以此类推</span></span><br><span class="line">还原稀疏数组:</span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">1</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">5</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">稀疏数组</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数组及多维数组</title>
    <link href="https://blog.myiszhb.cn/2020/12/02/4cb979a2.html"/>
    <id>https://blog.myiszhb.cn/2020/12/02/4cb979a2.html</id>
    <published>2020-12-02T12:13:24.000Z</published>
    <updated>2020-12-11T12:20:14.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h1><ol><li>数组时相同类型数据的有序集合。</li><li>数据描述的时相同类型的若干个数据，按照一定的先后次序排列组合而成。</li><li>其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们。</li></ol><h1 id="数组的4个基本特点"><a href="#数组的4个基本特点" class="headerlink" title="数组的4个基本特点"></a>数组的4个基本特点</h1><ol><li>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</li><li>其元素必须是相同类型，不允许出现混合类型。</li><li>数组中的元素可以是任何数据类型，包括旗本类型和引用类型。</li><li><code>数组变量属引用类型</code>，数组也可以看成对象，数组中的每个元素相当于对象的成员变量。数组本身就是对象，Java中对象是在推中的，因此数组无论保存原始类型还是其他对象类型，<code>数组对象本身就是堆中的</code></li><li>数组在内存方面存储的时候，数组中的元素内存地址是连续的。</li></ol><h1 id="数组这种数据结构的优点和缺点"><a href="#数组这种数据结构的优点和缺点" class="headerlink" title="数组这种数据结构的优点和缺点?"></a>数组这种数据结构的优点和缺点?</h1><ol><li>优点 查询/查找/检索某个下标上的元素时效极高，可以说是查询效率最高的一个数据结构。<br>  为什么检索效率高？<ol><li>每一个元素的内存地址在空间存储上是连续的。</li><li>每一个元素类型相同，所以占用空间大小一样。</li><li>知道第一个元素内存地址，知道每一个元素占用空间的大小，又知道下标，所以通过一个数学表达式就可以计算出某个下标元素上元素的内存地址，直接通过内存地址定位元素，所以数组的检索效率是最高的。</li><li><code>数组中存储100个元素或者存储100w个元素，在效率是相同的，因为数组中的元素不是一个个找的，而是通过数学表达式算内存地址直接定位的</code></li></ol></li><li>缺点<ol><li>由于为了保证数组中每个元素的内存地址连续，所以在数组中随机删除和添加的时候，效率较低，因为随机增删元素都会影响后面元素的位移操作（<code>注意：对于数组最后一个元素的增删，是没用效率影响的</code>）。</li><li>数组不能存储大数据量，为什么？<br>因为很难再内存空间上找到一块特别大的连续的内存空间.</li></ol></li></ol><h1 id="数组的3种初始化"><a href="#数组的3种初始化" class="headerlink" title="数组的3种初始化"></a>数组的3种初始化</h1><ol><li>静态初始化</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] num = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>动态初始化</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">num[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">num[<span class="number">2</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>默认初始化<br>数组才被创建的时候，就有默认的值，这个值也就是数组类型的默认值。</li></ol><p><code>备注：变量是放在栈里面的，new出来的是放在堆里面的</code></p><h1 id="数组的扩容"><a href="#数组的扩容" class="headerlink" title="数组的扩容"></a>数组的扩容</h1><p>关于一位数组的扩容。<br>Java中对数组的扩容是: 先新建一个大容量的数组然后将小容量数组中的数据一个个拷贝到大数组中。<br><code>总结:数组扩容效率较低，因为涉及到拷贝的问题，所以尽可能少的进行数组的拷贝 </code><br>可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这要可以减少数组的扩容次数，提高效率</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拷贝源（从这个数组中拷贝）</span></span><br><span class="line">        <span class="keyword">int</span>[] src = &#123;<span class="number">1</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拷贝目标（拷贝到这个目标数组上）</span></span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 调用jdk System类中的arraycopy方法进行数据的拷贝</span></span><br><span class="line"><span class="comment">         * arraycopy方法对应参数如下</span></span><br><span class="line"><span class="comment">         * src 拷贝源</span></span><br><span class="line"><span class="comment">         * srcPos 拷贝的起始位置</span></span><br><span class="line"><span class="comment">         * dest 拷贝目标</span></span><br><span class="line"><span class="comment">         * destPos 拷贝到目标的起始位置</span></span><br><span class="line"><span class="comment">         * length 拷贝长度</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        System.arraycopy(src,<span class="number">1</span>,dest,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多位数组"><a href="#多位数组" class="headerlink" title="多位数组"></a>多位数组</h1><ul><li>多维数组可以看出是数组的数组，比如二位数组就是一个特殊的一位数组，其每一个元素都是一个一位数组（<a href="https://www.processon.com/view/link/5f49dce26376890e62f836a6/">二位数组图点击查看</a>）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">5</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//arry[3][2]</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1,2 arry[0]</span></span><br><span class="line"><span class="comment">            3,4 arry[1]</span></span><br><span class="line"><span class="comment">            5,6 arry[2]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span>[][] arry = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arry.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arry[i].length; j++)&#123;</span><br><span class="line">                System.out.println(arry[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数组及多维数组</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java方法</title>
    <link href="https://blog.myiszhb.cn/2020/12/01/7a37a823.html"/>
    <id>https://blog.myiszhb.cn/2020/12/01/7a37a823.html</id>
    <published>2020-12-01T12:12:08.000Z</published>
    <updated>2020-12-11T12:20:26.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何谓方法？"><a href="#何谓方法？" class="headerlink" title="何谓方法？"></a>何谓方法？</h1><p>Java方法是语句的集合，它们在一起执行一个功能。</p><ol><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ol><h1 id="设计方法的原则"><a href="#设计方法的原则" class="headerlink" title="设计方法的原则"></a>设计方法的原则</h1><p>方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的<code>原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展</code></p><h1 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h1><p>方法包含一个方法头河一个方法体</p><ul><li>修饰符：修饰符，这是可选的，告诉编译器如何调用该方法，定义了方法的访问类型。</li><li>返回值：方法可能会有返回值。</li><li>方法名：参数像是一个占位符，当方法被调用时，传递值给参数。</li><li>参数类型：参数是可选的，方法可以不包含任何参数。<ol><li>形式参数：在方法被调用时用于接收外界传入的数据</li><li>实参：调用方法是实际给方法的数据</li></ol></li><li>方法体：方法体包含具体的语句，定义该方法的功能。</li></ul><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ol><li>什么是值传递？<br><code>值传递是对基本类型而言，传递的是该变量的副本，改变副本不影响原变量</code></li><li>什么是引用传递？<br><code>引用传递一般是对对象变量而言，传递的是该对象的地址副本，并不是原对象本身。所以引用对象进行操作会同时改变原对象。</code></li></ol><p><code>所以一般认为Java类的传递都是值传递，而这个值，实际上是对象的引用。</code></p><h1 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h1><ol><li>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</li><li>方法的重载的规则：<ul><li>方法名称必须相同。</li><li>参数列表必须不同（个数不同、或者类型不同、参数排列顺序不同）。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为方法的重载。</li></ul></li></ol><p><code>总结：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</code></p><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><pre><code>JDK1.5开始，Java支持传递同类型的可变参数给一个方法。在方法声明中，在指定参数类型后加一个省略号（...）。一个方法中只能指定一个可变参数，它碧血时方法的最后一个参数，任何普通的参数必须在它之前声明</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>... number)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java方法</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>什么是变量、常量、作用域、final关键字以及变量的命名规范</title>
    <link href="https://blog.myiszhb.cn/2020/11/30/c278e9dc.html"/>
    <id>https://blog.myiszhb.cn/2020/11/30/c278e9dc.html</id>
    <published>2020-11-30T12:00:53.000Z</published>
    <updated>2020-12-11T12:20:09.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol><li>变量是什么：就是可以变化的数据!</li><li>Java是一种强类型语言，每个变量都必须声明其类型。</li><li>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String userName = <span class="string">&quot;张三&quot;</span>；</span><br><span class="line"><span class="comment">//String 是数据类型</span></span><br><span class="line"><span class="comment">//userName 是变量名</span></span><br><span class="line"><span class="comment">//张三 是值</span></span><br></pre></td></tr></table></figure><p><code>注意</code></p><ul><li><code>每个变量都必须有类型，类型可以是基本类型，也可以是引用类型</code>。</li><li><code>变量名必须是合法的标识符</code>。</li><li><code>变量声明是一个完整的语句，因此每一个声明都必须以分号结束</code>。</li></ul><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ul><li>类变量（也可以叫做成员变量。使用static修饰）</li><li>实例变量</li><li>局部变量（写在方法里的）</li><li>Java中有一个很重要的原则：就近原则，那个就访问那个</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//这个是类变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这个是实例变量</span></span><br><span class="line">    String str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//这个是局部变量</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里i=0，这里就是Java中的就近原则</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="comment">//c变量赋值100，a、b只声明了没有赋值</span></span><br><span class="line">        <span class="keyword">int</span> a,b,c = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//这样每个都赋值了。</span></span><br><span class="line">        <span class="keyword">int</span> d=<span class="number">10</span>，e=<span class="number">10</span>,f=<span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ol><li>常量是初始化后不能再改变值!不会变动的值。</li><li>所谓常量可以理解成一种特殊的变量，它的值背设定后，在程序运行过程中不允许改变。</li><li>常量名一般用大写。</li><li>常量使用final关键字修饰</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//NUM就是常量 但是要使用final关键字修饰</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> NUM = <span class="number">2500</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h1><ol><li>所有变量、方法、类名要==见名如意==</li><li>类成员变量：首字母小写和驼峰原则：monthSalary</li><li>局部变量：首字母小写和驼峰原则</li><li>常量：首字母大写和下划线：MAX_VALUE</li><li>类名：首字母大写和驼峰原则：Man，GoodMan</li><li>方法名：首字母小写和驼峰原则：run(),runRun()</li></ol><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><ol><li>final是Java语言中的一个关键字。</li><li>final表示最终的，不可变的。</li><li>final可以修饰变量以及方法，还有类等。</li><li>final修饰的变量？<br>final修饰的变量，只能赋一次值，不允许被重新赋值。</li><li>final修饰的方法？<br>final修饰的方法无法被覆盖，被重写。</li><li>final修饰的类？<br>final修饰的类无法被继承</li><li>final控制不了能不能被调用的问题。final管的是啥？<br>final修饰的表示最后的，不能变得，不能改的。</li><li>final修饰的引用会怎么样呢？<br>final修饰的引用只能指向一个对象，不能被修改</li><li>final修饰的实例变量，系统不会赋默认值，必须手动赋值。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]agrs)</span></span>&#123;</span><br><span class="line">    <span class="comment">//final修饰的引用只能指向一个对象 ，但是被new出来的对象在堆中是可以被修改的</span></span><br><span class="line">        <span class="keyword">final</span> C c =<span class="keyword">new</span> C();</span><br><span class="line">        c.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(c.getName());</span><br><span class="line">        c.setName(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        System.out.println(c.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">张三</span><br><span class="line">王五</span><br></pre></td></tr></table></figure><h2 id="关于final赋值问题"><a href="#关于final赋值问题" class="headerlink" title="关于final赋值问题"></a>关于final赋值问题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="comment">//Java默认不会给final赋默认值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> i;</span><br><span class="line">    <span class="comment">//如果不在构造方法里赋值，程序启动报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i=<span class="number">80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">什么是变量、常量、作用域、final关键字以及变量的命名规范</summary>
    
    
    
    <category term="Java" scheme="https://blog.myiszhb.cn/categories/Java/"/>
    
    <category term="se" scheme="https://blog.myiszhb.cn/categories/Java/se/"/>
    
    
    <category term="Java基础" scheme="https://blog.myiszhb.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
